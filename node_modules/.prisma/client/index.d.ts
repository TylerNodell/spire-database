import {
  DMMF,
  DMMFClass,
  Engine,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  sqltag as sql,
  empty,
  join,
  raw,
} from '@prisma/client/runtime';

export { PrismaClientKnownRequestError }
export { PrismaClientUnknownRequestError }
export { PrismaClientRustPanicError }
export { PrismaClientInitializationError }
export { PrismaClientValidationError }

/**
 * Re-export of sql-template-tag
 */
export { sql, empty, join, raw }

/**
 * Prisma Client JS version: 2.4.1
 * Query Engine version: 5c2ad460cf4fe8c9330e6640b266c046542c8b6a
 */
export declare type PrismaVersion = {
  client: string
}

export declare const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export declare type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export declare interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export declare type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export declare type InputJsonObject = {[Key in string]?: JsonValue}
 
export declare interface InputJsonArray extends Array<JsonValue> {}
 
export declare type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray

declare type SelectAndInclude = {
  select: any
  include: any
}

declare type HasSelect = {
  select: any
}

declare type HasInclude = {
  include: any
}

declare type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export declare type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export declare type Enumerable<T> = T | Array<T>;

export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

export declare type TruthyKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

export declare type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}


/**
 * Client
**/

export declare type Datasource = {
  url?: string
}

export type Datasources = {
  db?: Datasource
}

export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your prisma.schema file
   */
  datasources?: Datasources

  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat

  /**
   * @example
   * ```
   * // Defaults to stdout
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events
   * log: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * ]
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: Array<LogLevel | LogDefinition>
}

export type Hooks = {
  beforeRequest?: (options: {query: string, path: string[], rootField?: string, typeName?: string, document: any}) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends Array<LogLevel | LogDefinition>> = GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]> 

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type Action =
  | 'findOne'
  | 'findMany'
  | 'create'
  | 'update'
  | 'updateMany'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'

/**
 * These options are being passed in to the middleware as "params"
 */
export type MiddlewareParams = {
  model?: string
  action: Action
  args: any
  dataPath: string[]
  runInTransaction: boolean
}

/**
 * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
 */
export type Middleware<T = any> = (
  params: MiddlewareParams,
  next: (params: MiddlewareParams) => Promise<T>,
) => Promise<T>

// tested in getLogLevel.test.ts
export declare function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Owners
 * const owners = await prisma.owner.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md).
 */
export declare class PrismaClient<
  T extends PrismaClientOptions = PrismaClientOptions,
  U = keyof T extends 'log' ? T['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<T['log']> : never : never
> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;
  /**
   * @private
   */
  private engine: Engine;
  /**
   * @private
   */
  private errorFormat: ErrorFormat;

  /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Owners
   * const owners = await prisma.owner.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md).
   */
  constructor(optionsArg?: T);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * @deprecated renamed to `$on`
   */
  on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * Connect with the database
   */
  $connect(): Promise<void>;
  /**
   * @deprecated renamed to `$connect`
   */
  connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;
  /**
   * @deprecated renamed to `$disconnect`
   */
  disconnect(): Promise<any>;

  

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md#raw-database-access).
  */
  $executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * @deprecated renamed to `$executeRaw`
   */
  executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md#raw-database-access).
  */
  $queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;
 
  /**
   * @deprecated renamed to `$executeRaw`
   */
  queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;

  /**
   * `prisma.owner`: Exposes CRUD operations for the **Owner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Owners
    * const owners = await prisma.owner.findMany()
    * ```
    */
  get owner(): OwnerDelegate;

  /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): TenantDelegate;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): AgentDelegate;

  /**
   * `prisma.building`: Exposes CRUD operations for the **Building** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Buildings
    * const buildings = await prisma.building.findMany()
    * ```
    */
  get building(): BuildingDelegate;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): UnitDelegate;

  /**
   * `prisma.occupant`: Exposes CRUD operations for the **Occupant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Occupants
    * const occupants = await prisma.occupant.findMany()
    * ```
    */
  get occupant(): OccupantDelegate;

  /**
   * `prisma.lease`: Exposes CRUD operations for the **Lease** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leases
    * const leases = await prisma.lease.findMany()
    * ```
    */
  get lease(): LeaseDelegate;

  /**
   * `prisma.salesListing`: Exposes CRUD operations for the **SalesListing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesListings
    * const salesListings = await prisma.salesListing.findMany()
    * ```
    */
  get salesListing(): SalesListingDelegate;

  /**
   * `prisma.serviceHistory`: Exposes CRUD operations for the **ServiceHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceHistories
    * const serviceHistories = await prisma.serviceHistory.findMany()
    * ```
    */
  get serviceHistory(): ServiceHistoryDelegate;

  /**
   * `prisma.serviceCompany`: Exposes CRUD operations for the **ServiceCompany** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceCompanies
    * const serviceCompanies = await prisma.serviceCompany.findMany()
    * ```
    */
  get serviceCompany(): ServiceCompanyDelegate;
}



/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export declare const OwnerDistinctFieldEnum: {
  id: 'id',
  createdAt: 'createdAt',
  name: 'name',
  address: 'address',
  phone: 'phone',
  email: 'email',
  notes: 'notes'
};

export declare type OwnerDistinctFieldEnum = (typeof OwnerDistinctFieldEnum)[keyof typeof OwnerDistinctFieldEnum]


export declare const TenantDistinctFieldEnum: {
  id: 'id',
  createdAt: 'createdAt',
  name: 'name',
  address: 'address',
  phone: 'phone',
  email: 'email',
  unitId: 'unitId',
  notes: 'notes'
};

export declare type TenantDistinctFieldEnum = (typeof TenantDistinctFieldEnum)[keyof typeof TenantDistinctFieldEnum]


export declare const AgentDistinctFieldEnum: {
  id: 'id',
  createdAt: 'createdAt',
  name: 'name',
  email: 'email',
  password: 'password',
  phone: 'phone',
  altPhone: 'altPhone'
};

export declare type AgentDistinctFieldEnum = (typeof AgentDistinctFieldEnum)[keyof typeof AgentDistinctFieldEnum]


export declare const BuildingDistinctFieldEnum: {
  id: 'id',
  createdAt: 'createdAt',
  address: 'address',
  name: 'name',
  phone: 'phone',
  email: 'email',
  notes: 'notes',
  insurance: 'insurance',
  boardPackages: 'boardPackages',
  salesapplication: 'salesapplication',
  salesPackage: 'salesPackage',
  specialDocuments: 'specialDocuments'
};

export declare type BuildingDistinctFieldEnum = (typeof BuildingDistinctFieldEnum)[keyof typeof BuildingDistinctFieldEnum]


export declare const UnitDistinctFieldEnum: {
  id: 'id',
  createdAt: 'createdAt',
  buildingId: 'buildingId',
  apt: 'apt',
  sale: 'sale',
  pets: 'pets',
  dogBreed: 'dogBreed',
  storageL: 'storageL',
  storageB: 'storageB',
  advertisement: 'advertisement',
  floorplan: 'floorplan',
  sqft: 'sqft',
  purchasePrice: 'purchasePrice',
  insurance: 'insurance',
  tenantInsurance: 'tenantInsurance'
};

export declare type UnitDistinctFieldEnum = (typeof UnitDistinctFieldEnum)[keyof typeof UnitDistinctFieldEnum]


export declare const OccupantDistinctFieldEnum: {
  id: 'id',
  createdAt: 'createdAt',
  name: 'name',
  email: 'email',
  phone: 'phone',
  unitId: 'unitId'
};

export declare type OccupantDistinctFieldEnum = (typeof OccupantDistinctFieldEnum)[keyof typeof OccupantDistinctFieldEnum]


export declare const LeaseDistinctFieldEnum: {
  id: 'id',
  createdAt: 'createdAt',
  unitId: 'unitId',
  term: 'term',
  amount: 'amount',
  extension: 'extension',
  notice: 'notice',
  showDate: 'showDate',
  security: 'security',
  pdfLeaseSigned: 'pdfLeaseSigned',
  pdfLeaseUnsigned: 'pdfLeaseUnsigned',
  wordRider: 'wordRider'
};

export declare type LeaseDistinctFieldEnum = (typeof LeaseDistinctFieldEnum)[keyof typeof LeaseDistinctFieldEnum]


export declare const SalesListingDistinctFieldEnum: {
  id: 'id',
  createdAt: 'createdAt'
};

export declare type SalesListingDistinctFieldEnum = (typeof SalesListingDistinctFieldEnum)[keyof typeof SalesListingDistinctFieldEnum]


export declare const ServiceHistoryDistinctFieldEnum: {
  id: 'id',
  createdAt: 'createdAt'
};

export declare type ServiceHistoryDistinctFieldEnum = (typeof ServiceHistoryDistinctFieldEnum)[keyof typeof ServiceHistoryDistinctFieldEnum]


export declare const ServiceCompanyDistinctFieldEnum: {
  id: 'id',
  createdAt: 'createdAt'
};

export declare type ServiceCompanyDistinctFieldEnum = (typeof ServiceCompanyDistinctFieldEnum)[keyof typeof ServiceCompanyDistinctFieldEnum]


export declare const SortOrder: {
  asc: 'asc',
  desc: 'desc'
};

export declare type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]



/**
 * Model Owner
 */

export type Owner = {
  id: number
  createdAt: Date
  name: string
  address: string
  phone: string | null
  email: string | null
  notes: string | null
}



export type OwnerSelect = {
  id?: boolean
  createdAt?: boolean
  name?: boolean
  address?: boolean
  phone?: boolean
  email?: boolean
  units?: boolean | FindManyUnitArgs
  notes?: boolean
}

export type OwnerInclude = {
  units?: boolean | FindManyUnitArgs
}

export type OwnerGetPayload<
  S extends boolean | null | undefined | OwnerArgs,
  U = keyof S
> = S extends true
  ? Owner
  : S extends undefined
  ? never
  : S extends OwnerArgs | FindManyOwnerArgs
  ? 'include' extends U
    ? Owner  & {
      [P in TrueKeys<S['include']>]:
      P extends 'units'
      ? Array<UnitGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Owner ? Owner[P]
: 
      P extends 'units'
      ? Array<UnitGetPayload<S['select'][P]>> : never
    }
  : Owner
: Owner


export interface OwnerDelegate {
  /**
   * Find zero or one Owner.
   * @param {FindOneOwnerArgs} args - Arguments to find a Owner
   * @example
   * // Get one Owner
   * const owner = await prisma.owner.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneOwnerArgs>(
    args: Subset<T, FindOneOwnerArgs>
  ): CheckSelect<T, Prisma__OwnerClient<Owner | null>, Prisma__OwnerClient<OwnerGetPayload<T> | null>>
  /**
   * Find zero or more Owners.
   * @param {FindManyOwnerArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Owners
   * const owners = await prisma.owner.findMany()
   * 
   * // Get first 10 Owners
   * const owners = await prisma.owner.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const ownerWithIdOnly = await prisma.owner.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyOwnerArgs>(
    args?: Subset<T, FindManyOwnerArgs>
  ): CheckSelect<T, Promise<Array<Owner>>, Promise<Array<OwnerGetPayload<T>>>>
  /**
   * Create a Owner.
   * @param {OwnerCreateArgs} args - Arguments to create a Owner.
   * @example
   * // Create one Owner
   * const Owner = await prisma.owner.create({
   *   data: {
   *     // ... data to create a Owner
   *   }
   * })
   * 
  **/
  create<T extends OwnerCreateArgs>(
    args: Subset<T, OwnerCreateArgs>
  ): CheckSelect<T, Prisma__OwnerClient<Owner>, Prisma__OwnerClient<OwnerGetPayload<T>>>
  /**
   * Delete a Owner.
   * @param {OwnerDeleteArgs} args - Arguments to delete one Owner.
   * @example
   * // Delete one Owner
   * const Owner = await prisma.owner.delete({
   *   where: {
   *     // ... filter to delete one Owner
   *   }
   * })
   * 
  **/
  delete<T extends OwnerDeleteArgs>(
    args: Subset<T, OwnerDeleteArgs>
  ): CheckSelect<T, Prisma__OwnerClient<Owner>, Prisma__OwnerClient<OwnerGetPayload<T>>>
  /**
   * Update one Owner.
   * @param {OwnerUpdateArgs} args - Arguments to update one Owner.
   * @example
   * // Update one Owner
   * const owner = await prisma.owner.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends OwnerUpdateArgs>(
    args: Subset<T, OwnerUpdateArgs>
  ): CheckSelect<T, Prisma__OwnerClient<Owner>, Prisma__OwnerClient<OwnerGetPayload<T>>>
  /**
   * Delete zero or more Owners.
   * @param {OwnerDeleteManyArgs} args - Arguments to filter Owners to delete.
   * @example
   * // Delete a few Owners
   * const { count } = await prisma.owner.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends OwnerDeleteManyArgs>(
    args: Subset<T, OwnerDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Owners.
   * @param {OwnerUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Owners
   * const owner = await prisma.owner.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends OwnerUpdateManyArgs>(
    args: Subset<T, OwnerUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Owner.
   * @param {OwnerUpsertArgs} args - Arguments to update or create a Owner.
   * @example
   * // Update or create a Owner
   * const owner = await prisma.owner.upsert({
   *   create: {
   *     // ... data to create a Owner
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Owner we want to update
   *   }
   * })
  **/
  upsert<T extends OwnerUpsertArgs>(
    args: Subset<T, OwnerUpsertArgs>
  ): CheckSelect<T, Prisma__OwnerClient<Owner>, Prisma__OwnerClient<OwnerGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyOwnerArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Owner.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__OwnerClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  units<T extends FindManyUnitArgs = {}>(args?: Subset<T, FindManyUnitArgs>): CheckSelect<T, Promise<Array<Unit>>, Promise<Array<UnitGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Owner findOne
 */
export type FindOneOwnerArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
  /**
   * Filter, which Owner to fetch.
  **/
  where: OwnerWhereUniqueInput
}


/**
 * Owner findMany
 */
export type FindManyOwnerArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
  /**
   * Filter, which Owners to fetch.
  **/
  where?: OwnerWhereInput
  /**
   * Determine the order of the Owners to fetch.
  **/
  orderBy?: Enumerable<OwnerOrderByInput>
  /**
   * Sets the position for listing Owners.
  **/
  cursor?: OwnerWhereUniqueInput
  /**
   * The number of Owners to fetch. If negative number, it will take Owners before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Owners.
  **/
  skip?: number
  distinct?: Enumerable<OwnerDistinctFieldEnum>
}


/**
 * Owner create
 */
export type OwnerCreateArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
  /**
   * The data needed to create a Owner.
  **/
  data: OwnerCreateInput
}


/**
 * Owner update
 */
export type OwnerUpdateArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
  /**
   * The data needed to update a Owner.
  **/
  data: OwnerUpdateInput
  /**
   * Choose, which Owner to update.
  **/
  where: OwnerWhereUniqueInput
}


/**
 * Owner updateMany
 */
export type OwnerUpdateManyArgs = {
  data: OwnerUpdateManyMutationInput
  where?: OwnerWhereInput
}


/**
 * Owner upsert
 */
export type OwnerUpsertArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
  /**
   * The filter to search for the Owner to update in case it exists.
  **/
  where: OwnerWhereUniqueInput
  /**
   * In case the Owner found by the `where` argument doesn't exist, create a new Owner with this data.
  **/
  create: OwnerCreateInput
  /**
   * In case the Owner was found with the provided `where` argument, update it with this data.
  **/
  update: OwnerUpdateInput
}


/**
 * Owner delete
 */
export type OwnerDeleteArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
  /**
   * Filter which Owner to delete.
  **/
  where: OwnerWhereUniqueInput
}


/**
 * Owner deleteMany
 */
export type OwnerDeleteManyArgs = {
  where?: OwnerWhereInput
}


/**
 * Owner without action
 */
export type OwnerArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
}



/**
 * Model Tenant
 */

export type Tenant = {
  id: number
  createdAt: Date
  name: string
  address: string
  phone: string | null
  email: string | null
  unitId: number | null
  notes: string | null
}



export type TenantSelect = {
  id?: boolean
  createdAt?: boolean
  name?: boolean
  address?: boolean
  phone?: boolean
  email?: boolean
  unit?: boolean | UnitArgs
  unitId?: boolean
  notes?: boolean
}

export type TenantInclude = {
  unit?: boolean | UnitArgs
}

export type TenantGetPayload<
  S extends boolean | null | undefined | TenantArgs,
  U = keyof S
> = S extends true
  ? Tenant
  : S extends undefined
  ? never
  : S extends TenantArgs | FindManyTenantArgs
  ? 'include' extends U
    ? Tenant  & {
      [P in TrueKeys<S['include']>]:
      P extends 'unit'
      ? UnitGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Tenant ? Tenant[P]
: 
      P extends 'unit'
      ? UnitGetPayload<S['select'][P]> | null : never
    }
  : Tenant
: Tenant


export interface TenantDelegate {
  /**
   * Find zero or one Tenant.
   * @param {FindOneTenantArgs} args - Arguments to find a Tenant
   * @example
   * // Get one Tenant
   * const tenant = await prisma.tenant.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneTenantArgs>(
    args: Subset<T, FindOneTenantArgs>
  ): CheckSelect<T, Prisma__TenantClient<Tenant | null>, Prisma__TenantClient<TenantGetPayload<T> | null>>
  /**
   * Find zero or more Tenants.
   * @param {FindManyTenantArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Tenants
   * const tenants = await prisma.tenant.findMany()
   * 
   * // Get first 10 Tenants
   * const tenants = await prisma.tenant.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyTenantArgs>(
    args?: Subset<T, FindManyTenantArgs>
  ): CheckSelect<T, Promise<Array<Tenant>>, Promise<Array<TenantGetPayload<T>>>>
  /**
   * Create a Tenant.
   * @param {TenantCreateArgs} args - Arguments to create a Tenant.
   * @example
   * // Create one Tenant
   * const Tenant = await prisma.tenant.create({
   *   data: {
   *     // ... data to create a Tenant
   *   }
   * })
   * 
  **/
  create<T extends TenantCreateArgs>(
    args: Subset<T, TenantCreateArgs>
  ): CheckSelect<T, Prisma__TenantClient<Tenant>, Prisma__TenantClient<TenantGetPayload<T>>>
  /**
   * Delete a Tenant.
   * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
   * @example
   * // Delete one Tenant
   * const Tenant = await prisma.tenant.delete({
   *   where: {
   *     // ... filter to delete one Tenant
   *   }
   * })
   * 
  **/
  delete<T extends TenantDeleteArgs>(
    args: Subset<T, TenantDeleteArgs>
  ): CheckSelect<T, Prisma__TenantClient<Tenant>, Prisma__TenantClient<TenantGetPayload<T>>>
  /**
   * Update one Tenant.
   * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
   * @example
   * // Update one Tenant
   * const tenant = await prisma.tenant.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends TenantUpdateArgs>(
    args: Subset<T, TenantUpdateArgs>
  ): CheckSelect<T, Prisma__TenantClient<Tenant>, Prisma__TenantClient<TenantGetPayload<T>>>
  /**
   * Delete zero or more Tenants.
   * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
   * @example
   * // Delete a few Tenants
   * const { count } = await prisma.tenant.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends TenantDeleteManyArgs>(
    args: Subset<T, TenantDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Tenants.
   * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Tenants
   * const tenant = await prisma.tenant.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends TenantUpdateManyArgs>(
    args: Subset<T, TenantUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Tenant.
   * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
   * @example
   * // Update or create a Tenant
   * const tenant = await prisma.tenant.upsert({
   *   create: {
   *     // ... data to create a Tenant
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Tenant we want to update
   *   }
   * })
  **/
  upsert<T extends TenantUpsertArgs>(
    args: Subset<T, TenantUpsertArgs>
  ): CheckSelect<T, Prisma__TenantClient<Tenant>, Prisma__TenantClient<TenantGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyTenantArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Tenant.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__TenantClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  unit<T extends UnitArgs = {}>(args?: Subset<T, UnitArgs>): CheckSelect<T, Prisma__UnitClient<Unit | null>, Prisma__UnitClient<UnitGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Tenant findOne
 */
export type FindOneTenantArgs = {
  /**
   * Select specific fields to fetch from the Tenant
  **/
  select?: TenantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TenantInclude | null
  /**
   * Filter, which Tenant to fetch.
  **/
  where: TenantWhereUniqueInput
}


/**
 * Tenant findMany
 */
export type FindManyTenantArgs = {
  /**
   * Select specific fields to fetch from the Tenant
  **/
  select?: TenantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TenantInclude | null
  /**
   * Filter, which Tenants to fetch.
  **/
  where?: TenantWhereInput
  /**
   * Determine the order of the Tenants to fetch.
  **/
  orderBy?: Enumerable<TenantOrderByInput>
  /**
   * Sets the position for listing Tenants.
  **/
  cursor?: TenantWhereUniqueInput
  /**
   * The number of Tenants to fetch. If negative number, it will take Tenants before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Tenants.
  **/
  skip?: number
  distinct?: Enumerable<TenantDistinctFieldEnum>
}


/**
 * Tenant create
 */
export type TenantCreateArgs = {
  /**
   * Select specific fields to fetch from the Tenant
  **/
  select?: TenantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TenantInclude | null
  /**
   * The data needed to create a Tenant.
  **/
  data: TenantCreateInput
}


/**
 * Tenant update
 */
export type TenantUpdateArgs = {
  /**
   * Select specific fields to fetch from the Tenant
  **/
  select?: TenantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TenantInclude | null
  /**
   * The data needed to update a Tenant.
  **/
  data: TenantUpdateInput
  /**
   * Choose, which Tenant to update.
  **/
  where: TenantWhereUniqueInput
}


/**
 * Tenant updateMany
 */
export type TenantUpdateManyArgs = {
  data: TenantUpdateManyMutationInput
  where?: TenantWhereInput
}


/**
 * Tenant upsert
 */
export type TenantUpsertArgs = {
  /**
   * Select specific fields to fetch from the Tenant
  **/
  select?: TenantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TenantInclude | null
  /**
   * The filter to search for the Tenant to update in case it exists.
  **/
  where: TenantWhereUniqueInput
  /**
   * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
  **/
  create: TenantCreateInput
  /**
   * In case the Tenant was found with the provided `where` argument, update it with this data.
  **/
  update: TenantUpdateInput
}


/**
 * Tenant delete
 */
export type TenantDeleteArgs = {
  /**
   * Select specific fields to fetch from the Tenant
  **/
  select?: TenantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TenantInclude | null
  /**
   * Filter which Tenant to delete.
  **/
  where: TenantWhereUniqueInput
}


/**
 * Tenant deleteMany
 */
export type TenantDeleteManyArgs = {
  where?: TenantWhereInput
}


/**
 * Tenant without action
 */
export type TenantArgs = {
  /**
   * Select specific fields to fetch from the Tenant
  **/
  select?: TenantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TenantInclude | null
}



/**
 * Model Agent
 */

export type Agent = {
  id: number
  createdAt: Date
  name: string
  email: string
  password: string
  phone: string
  altPhone: string
}



export type AgentSelect = {
  id?: boolean
  createdAt?: boolean
  name?: boolean
  email?: boolean
  password?: boolean
  phone?: boolean
  altPhone?: boolean
  units?: boolean | FindManyUnitArgs
}

export type AgentInclude = {
  units?: boolean | FindManyUnitArgs
}

export type AgentGetPayload<
  S extends boolean | null | undefined | AgentArgs,
  U = keyof S
> = S extends true
  ? Agent
  : S extends undefined
  ? never
  : S extends AgentArgs | FindManyAgentArgs
  ? 'include' extends U
    ? Agent  & {
      [P in TrueKeys<S['include']>]:
      P extends 'units'
      ? Array<UnitGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Agent ? Agent[P]
: 
      P extends 'units'
      ? Array<UnitGetPayload<S['select'][P]>> : never
    }
  : Agent
: Agent


export interface AgentDelegate {
  /**
   * Find zero or one Agent.
   * @param {FindOneAgentArgs} args - Arguments to find a Agent
   * @example
   * // Get one Agent
   * const agent = await prisma.agent.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneAgentArgs>(
    args: Subset<T, FindOneAgentArgs>
  ): CheckSelect<T, Prisma__AgentClient<Agent | null>, Prisma__AgentClient<AgentGetPayload<T> | null>>
  /**
   * Find zero or more Agents.
   * @param {FindManyAgentArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Agents
   * const agents = await prisma.agent.findMany()
   * 
   * // Get first 10 Agents
   * const agents = await prisma.agent.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyAgentArgs>(
    args?: Subset<T, FindManyAgentArgs>
  ): CheckSelect<T, Promise<Array<Agent>>, Promise<Array<AgentGetPayload<T>>>>
  /**
   * Create a Agent.
   * @param {AgentCreateArgs} args - Arguments to create a Agent.
   * @example
   * // Create one Agent
   * const Agent = await prisma.agent.create({
   *   data: {
   *     // ... data to create a Agent
   *   }
   * })
   * 
  **/
  create<T extends AgentCreateArgs>(
    args: Subset<T, AgentCreateArgs>
  ): CheckSelect<T, Prisma__AgentClient<Agent>, Prisma__AgentClient<AgentGetPayload<T>>>
  /**
   * Delete a Agent.
   * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
   * @example
   * // Delete one Agent
   * const Agent = await prisma.agent.delete({
   *   where: {
   *     // ... filter to delete one Agent
   *   }
   * })
   * 
  **/
  delete<T extends AgentDeleteArgs>(
    args: Subset<T, AgentDeleteArgs>
  ): CheckSelect<T, Prisma__AgentClient<Agent>, Prisma__AgentClient<AgentGetPayload<T>>>
  /**
   * Update one Agent.
   * @param {AgentUpdateArgs} args - Arguments to update one Agent.
   * @example
   * // Update one Agent
   * const agent = await prisma.agent.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends AgentUpdateArgs>(
    args: Subset<T, AgentUpdateArgs>
  ): CheckSelect<T, Prisma__AgentClient<Agent>, Prisma__AgentClient<AgentGetPayload<T>>>
  /**
   * Delete zero or more Agents.
   * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
   * @example
   * // Delete a few Agents
   * const { count } = await prisma.agent.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends AgentDeleteManyArgs>(
    args: Subset<T, AgentDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Agents.
   * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Agents
   * const agent = await prisma.agent.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends AgentUpdateManyArgs>(
    args: Subset<T, AgentUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Agent.
   * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
   * @example
   * // Update or create a Agent
   * const agent = await prisma.agent.upsert({
   *   create: {
   *     // ... data to create a Agent
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Agent we want to update
   *   }
   * })
  **/
  upsert<T extends AgentUpsertArgs>(
    args: Subset<T, AgentUpsertArgs>
  ): CheckSelect<T, Prisma__AgentClient<Agent>, Prisma__AgentClient<AgentGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyAgentArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Agent.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__AgentClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  units<T extends FindManyUnitArgs = {}>(args?: Subset<T, FindManyUnitArgs>): CheckSelect<T, Promise<Array<Unit>>, Promise<Array<UnitGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Agent findOne
 */
export type FindOneAgentArgs = {
  /**
   * Select specific fields to fetch from the Agent
  **/
  select?: AgentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AgentInclude | null
  /**
   * Filter, which Agent to fetch.
  **/
  where: AgentWhereUniqueInput
}


/**
 * Agent findMany
 */
export type FindManyAgentArgs = {
  /**
   * Select specific fields to fetch from the Agent
  **/
  select?: AgentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AgentInclude | null
  /**
   * Filter, which Agents to fetch.
  **/
  where?: AgentWhereInput
  /**
   * Determine the order of the Agents to fetch.
  **/
  orderBy?: Enumerable<AgentOrderByInput>
  /**
   * Sets the position for listing Agents.
  **/
  cursor?: AgentWhereUniqueInput
  /**
   * The number of Agents to fetch. If negative number, it will take Agents before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Agents.
  **/
  skip?: number
  distinct?: Enumerable<AgentDistinctFieldEnum>
}


/**
 * Agent create
 */
export type AgentCreateArgs = {
  /**
   * Select specific fields to fetch from the Agent
  **/
  select?: AgentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AgentInclude | null
  /**
   * The data needed to create a Agent.
  **/
  data: AgentCreateInput
}


/**
 * Agent update
 */
export type AgentUpdateArgs = {
  /**
   * Select specific fields to fetch from the Agent
  **/
  select?: AgentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AgentInclude | null
  /**
   * The data needed to update a Agent.
  **/
  data: AgentUpdateInput
  /**
   * Choose, which Agent to update.
  **/
  where: AgentWhereUniqueInput
}


/**
 * Agent updateMany
 */
export type AgentUpdateManyArgs = {
  data: AgentUpdateManyMutationInput
  where?: AgentWhereInput
}


/**
 * Agent upsert
 */
export type AgentUpsertArgs = {
  /**
   * Select specific fields to fetch from the Agent
  **/
  select?: AgentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AgentInclude | null
  /**
   * The filter to search for the Agent to update in case it exists.
  **/
  where: AgentWhereUniqueInput
  /**
   * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
  **/
  create: AgentCreateInput
  /**
   * In case the Agent was found with the provided `where` argument, update it with this data.
  **/
  update: AgentUpdateInput
}


/**
 * Agent delete
 */
export type AgentDeleteArgs = {
  /**
   * Select specific fields to fetch from the Agent
  **/
  select?: AgentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AgentInclude | null
  /**
   * Filter which Agent to delete.
  **/
  where: AgentWhereUniqueInput
}


/**
 * Agent deleteMany
 */
export type AgentDeleteManyArgs = {
  where?: AgentWhereInput
}


/**
 * Agent without action
 */
export type AgentArgs = {
  /**
   * Select specific fields to fetch from the Agent
  **/
  select?: AgentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AgentInclude | null
}



/**
 * Model Building
 */

export type Building = {
  id: number
  createdAt: Date
  address: string
  name: string | null
  phone: string
  email: string
  notes: string
  insurance: string
  boardPackages: string
  salesapplication: string
  salesPackage: string
  specialDocuments: string
}



export type BuildingSelect = {
  id?: boolean
  createdAt?: boolean
  address?: boolean
  name?: boolean
  phone?: boolean
  email?: boolean
  units?: boolean | FindManyUnitArgs
  notes?: boolean
  insurance?: boolean
  boardPackages?: boolean
  salesapplication?: boolean
  salesPackage?: boolean
  specialDocuments?: boolean
}

export type BuildingInclude = {
  units?: boolean | FindManyUnitArgs
}

export type BuildingGetPayload<
  S extends boolean | null | undefined | BuildingArgs,
  U = keyof S
> = S extends true
  ? Building
  : S extends undefined
  ? never
  : S extends BuildingArgs | FindManyBuildingArgs
  ? 'include' extends U
    ? Building  & {
      [P in TrueKeys<S['include']>]:
      P extends 'units'
      ? Array<UnitGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Building ? Building[P]
: 
      P extends 'units'
      ? Array<UnitGetPayload<S['select'][P]>> : never
    }
  : Building
: Building


export interface BuildingDelegate {
  /**
   * Find zero or one Building.
   * @param {FindOneBuildingArgs} args - Arguments to find a Building
   * @example
   * // Get one Building
   * const building = await prisma.building.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneBuildingArgs>(
    args: Subset<T, FindOneBuildingArgs>
  ): CheckSelect<T, Prisma__BuildingClient<Building | null>, Prisma__BuildingClient<BuildingGetPayload<T> | null>>
  /**
   * Find zero or more Buildings.
   * @param {FindManyBuildingArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Buildings
   * const buildings = await prisma.building.findMany()
   * 
   * // Get first 10 Buildings
   * const buildings = await prisma.building.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const buildingWithIdOnly = await prisma.building.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyBuildingArgs>(
    args?: Subset<T, FindManyBuildingArgs>
  ): CheckSelect<T, Promise<Array<Building>>, Promise<Array<BuildingGetPayload<T>>>>
  /**
   * Create a Building.
   * @param {BuildingCreateArgs} args - Arguments to create a Building.
   * @example
   * // Create one Building
   * const Building = await prisma.building.create({
   *   data: {
   *     // ... data to create a Building
   *   }
   * })
   * 
  **/
  create<T extends BuildingCreateArgs>(
    args: Subset<T, BuildingCreateArgs>
  ): CheckSelect<T, Prisma__BuildingClient<Building>, Prisma__BuildingClient<BuildingGetPayload<T>>>
  /**
   * Delete a Building.
   * @param {BuildingDeleteArgs} args - Arguments to delete one Building.
   * @example
   * // Delete one Building
   * const Building = await prisma.building.delete({
   *   where: {
   *     // ... filter to delete one Building
   *   }
   * })
   * 
  **/
  delete<T extends BuildingDeleteArgs>(
    args: Subset<T, BuildingDeleteArgs>
  ): CheckSelect<T, Prisma__BuildingClient<Building>, Prisma__BuildingClient<BuildingGetPayload<T>>>
  /**
   * Update one Building.
   * @param {BuildingUpdateArgs} args - Arguments to update one Building.
   * @example
   * // Update one Building
   * const building = await prisma.building.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends BuildingUpdateArgs>(
    args: Subset<T, BuildingUpdateArgs>
  ): CheckSelect<T, Prisma__BuildingClient<Building>, Prisma__BuildingClient<BuildingGetPayload<T>>>
  /**
   * Delete zero or more Buildings.
   * @param {BuildingDeleteManyArgs} args - Arguments to filter Buildings to delete.
   * @example
   * // Delete a few Buildings
   * const { count } = await prisma.building.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends BuildingDeleteManyArgs>(
    args: Subset<T, BuildingDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Buildings.
   * @param {BuildingUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Buildings
   * const building = await prisma.building.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends BuildingUpdateManyArgs>(
    args: Subset<T, BuildingUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Building.
   * @param {BuildingUpsertArgs} args - Arguments to update or create a Building.
   * @example
   * // Update or create a Building
   * const building = await prisma.building.upsert({
   *   create: {
   *     // ... data to create a Building
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Building we want to update
   *   }
   * })
  **/
  upsert<T extends BuildingUpsertArgs>(
    args: Subset<T, BuildingUpsertArgs>
  ): CheckSelect<T, Prisma__BuildingClient<Building>, Prisma__BuildingClient<BuildingGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyBuildingArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Building.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__BuildingClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  units<T extends FindManyUnitArgs = {}>(args?: Subset<T, FindManyUnitArgs>): CheckSelect<T, Promise<Array<Unit>>, Promise<Array<UnitGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Building findOne
 */
export type FindOneBuildingArgs = {
  /**
   * Select specific fields to fetch from the Building
  **/
  select?: BuildingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BuildingInclude | null
  /**
   * Filter, which Building to fetch.
  **/
  where: BuildingWhereUniqueInput
}


/**
 * Building findMany
 */
export type FindManyBuildingArgs = {
  /**
   * Select specific fields to fetch from the Building
  **/
  select?: BuildingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BuildingInclude | null
  /**
   * Filter, which Buildings to fetch.
  **/
  where?: BuildingWhereInput
  /**
   * Determine the order of the Buildings to fetch.
  **/
  orderBy?: Enumerable<BuildingOrderByInput>
  /**
   * Sets the position for listing Buildings.
  **/
  cursor?: BuildingWhereUniqueInput
  /**
   * The number of Buildings to fetch. If negative number, it will take Buildings before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Buildings.
  **/
  skip?: number
  distinct?: Enumerable<BuildingDistinctFieldEnum>
}


/**
 * Building create
 */
export type BuildingCreateArgs = {
  /**
   * Select specific fields to fetch from the Building
  **/
  select?: BuildingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BuildingInclude | null
  /**
   * The data needed to create a Building.
  **/
  data: BuildingCreateInput
}


/**
 * Building update
 */
export type BuildingUpdateArgs = {
  /**
   * Select specific fields to fetch from the Building
  **/
  select?: BuildingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BuildingInclude | null
  /**
   * The data needed to update a Building.
  **/
  data: BuildingUpdateInput
  /**
   * Choose, which Building to update.
  **/
  where: BuildingWhereUniqueInput
}


/**
 * Building updateMany
 */
export type BuildingUpdateManyArgs = {
  data: BuildingUpdateManyMutationInput
  where?: BuildingWhereInput
}


/**
 * Building upsert
 */
export type BuildingUpsertArgs = {
  /**
   * Select specific fields to fetch from the Building
  **/
  select?: BuildingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BuildingInclude | null
  /**
   * The filter to search for the Building to update in case it exists.
  **/
  where: BuildingWhereUniqueInput
  /**
   * In case the Building found by the `where` argument doesn't exist, create a new Building with this data.
  **/
  create: BuildingCreateInput
  /**
   * In case the Building was found with the provided `where` argument, update it with this data.
  **/
  update: BuildingUpdateInput
}


/**
 * Building delete
 */
export type BuildingDeleteArgs = {
  /**
   * Select specific fields to fetch from the Building
  **/
  select?: BuildingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BuildingInclude | null
  /**
   * Filter which Building to delete.
  **/
  where: BuildingWhereUniqueInput
}


/**
 * Building deleteMany
 */
export type BuildingDeleteManyArgs = {
  where?: BuildingWhereInput
}


/**
 * Building without action
 */
export type BuildingArgs = {
  /**
   * Select specific fields to fetch from the Building
  **/
  select?: BuildingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BuildingInclude | null
}



/**
 * Model Unit
 */

export type Unit = {
  id: number
  createdAt: Date
  buildingId: number
  apt: string
  sale: boolean
  pets: boolean | null
  dogBreed: string | null
  storageL: boolean | null
  storageB: boolean | null
  advertisement: string
  floorplan: string | null
  sqft: number | null
  purchasePrice: number | null
  insurance: string | null
  tenantInsurance: string | null
}



export type UnitSelect = {
  id?: boolean
  createdAt?: boolean
  buildingId?: boolean
  apt?: boolean
  sale?: boolean
  agent?: boolean | FindManyAgentArgs
  building?: boolean | BuildingArgs
  owner?: boolean | FindManyOwnerArgs
  tenant?: boolean | FindManyTenantArgs
  lease?: boolean | LeaseArgs
  pets?: boolean
  dogBreed?: boolean
  storageL?: boolean
  storageB?: boolean
  advertisement?: boolean
  occupants?: boolean | FindManyOccupantArgs
  floorplan?: boolean
  sqft?: boolean
  purchasePrice?: boolean
  insurance?: boolean
  tenantInsurance?: boolean
}

export type UnitInclude = {
  agent?: boolean | FindManyAgentArgs
  building?: boolean | BuildingArgs
  owner?: boolean | FindManyOwnerArgs
  tenant?: boolean | FindManyTenantArgs
  lease?: boolean | LeaseArgs
  occupants?: boolean | FindManyOccupantArgs
}

export type UnitGetPayload<
  S extends boolean | null | undefined | UnitArgs,
  U = keyof S
> = S extends true
  ? Unit
  : S extends undefined
  ? never
  : S extends UnitArgs | FindManyUnitArgs
  ? 'include' extends U
    ? Unit  & {
      [P in TrueKeys<S['include']>]:
      P extends 'agent'
      ? Array<AgentGetPayload<S['include'][P]>> :
      P extends 'building'
      ? BuildingGetPayload<S['include'][P]> :
      P extends 'owner'
      ? Array<OwnerGetPayload<S['include'][P]>> :
      P extends 'tenant'
      ? Array<TenantGetPayload<S['include'][P]>> :
      P extends 'lease'
      ? LeaseGetPayload<S['include'][P]> :
      P extends 'occupants'
      ? Array<OccupantGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Unit ? Unit[P]
: 
      P extends 'agent'
      ? Array<AgentGetPayload<S['select'][P]>> :
      P extends 'building'
      ? BuildingGetPayload<S['select'][P]> :
      P extends 'owner'
      ? Array<OwnerGetPayload<S['select'][P]>> :
      P extends 'tenant'
      ? Array<TenantGetPayload<S['select'][P]>> :
      P extends 'lease'
      ? LeaseGetPayload<S['select'][P]> :
      P extends 'occupants'
      ? Array<OccupantGetPayload<S['select'][P]>> : never
    }
  : Unit
: Unit


export interface UnitDelegate {
  /**
   * Find zero or one Unit.
   * @param {FindOneUnitArgs} args - Arguments to find a Unit
   * @example
   * // Get one Unit
   * const unit = await prisma.unit.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneUnitArgs>(
    args: Subset<T, FindOneUnitArgs>
  ): CheckSelect<T, Prisma__UnitClient<Unit | null>, Prisma__UnitClient<UnitGetPayload<T> | null>>
  /**
   * Find zero or more Units.
   * @param {FindManyUnitArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Units
   * const units = await prisma.unit.findMany()
   * 
   * // Get first 10 Units
   * const units = await prisma.unit.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyUnitArgs>(
    args?: Subset<T, FindManyUnitArgs>
  ): CheckSelect<T, Promise<Array<Unit>>, Promise<Array<UnitGetPayload<T>>>>
  /**
   * Create a Unit.
   * @param {UnitCreateArgs} args - Arguments to create a Unit.
   * @example
   * // Create one Unit
   * const Unit = await prisma.unit.create({
   *   data: {
   *     // ... data to create a Unit
   *   }
   * })
   * 
  **/
  create<T extends UnitCreateArgs>(
    args: Subset<T, UnitCreateArgs>
  ): CheckSelect<T, Prisma__UnitClient<Unit>, Prisma__UnitClient<UnitGetPayload<T>>>
  /**
   * Delete a Unit.
   * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
   * @example
   * // Delete one Unit
   * const Unit = await prisma.unit.delete({
   *   where: {
   *     // ... filter to delete one Unit
   *   }
   * })
   * 
  **/
  delete<T extends UnitDeleteArgs>(
    args: Subset<T, UnitDeleteArgs>
  ): CheckSelect<T, Prisma__UnitClient<Unit>, Prisma__UnitClient<UnitGetPayload<T>>>
  /**
   * Update one Unit.
   * @param {UnitUpdateArgs} args - Arguments to update one Unit.
   * @example
   * // Update one Unit
   * const unit = await prisma.unit.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends UnitUpdateArgs>(
    args: Subset<T, UnitUpdateArgs>
  ): CheckSelect<T, Prisma__UnitClient<Unit>, Prisma__UnitClient<UnitGetPayload<T>>>
  /**
   * Delete zero or more Units.
   * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
   * @example
   * // Delete a few Units
   * const { count } = await prisma.unit.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends UnitDeleteManyArgs>(
    args: Subset<T, UnitDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Units.
   * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Units
   * const unit = await prisma.unit.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends UnitUpdateManyArgs>(
    args: Subset<T, UnitUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Unit.
   * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
   * @example
   * // Update or create a Unit
   * const unit = await prisma.unit.upsert({
   *   create: {
   *     // ... data to create a Unit
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Unit we want to update
   *   }
   * })
  **/
  upsert<T extends UnitUpsertArgs>(
    args: Subset<T, UnitUpsertArgs>
  ): CheckSelect<T, Prisma__UnitClient<Unit>, Prisma__UnitClient<UnitGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyUnitArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Unit.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__UnitClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  agent<T extends FindManyAgentArgs = {}>(args?: Subset<T, FindManyAgentArgs>): CheckSelect<T, Promise<Array<Agent>>, Promise<Array<AgentGetPayload<T>>>>;

  building<T extends BuildingArgs = {}>(args?: Subset<T, BuildingArgs>): CheckSelect<T, Prisma__BuildingClient<Building | null>, Prisma__BuildingClient<BuildingGetPayload<T> | null>>;

  owner<T extends FindManyOwnerArgs = {}>(args?: Subset<T, FindManyOwnerArgs>): CheckSelect<T, Promise<Array<Owner>>, Promise<Array<OwnerGetPayload<T>>>>;

  tenant<T extends FindManyTenantArgs = {}>(args?: Subset<T, FindManyTenantArgs>): CheckSelect<T, Promise<Array<Tenant>>, Promise<Array<TenantGetPayload<T>>>>;

  lease<T extends LeaseArgs = {}>(args?: Subset<T, LeaseArgs>): CheckSelect<T, Prisma__LeaseClient<Lease | null>, Prisma__LeaseClient<LeaseGetPayload<T> | null>>;

  occupants<T extends FindManyOccupantArgs = {}>(args?: Subset<T, FindManyOccupantArgs>): CheckSelect<T, Promise<Array<Occupant>>, Promise<Array<OccupantGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Unit findOne
 */
export type FindOneUnitArgs = {
  /**
   * Select specific fields to fetch from the Unit
  **/
  select?: UnitSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UnitInclude | null
  /**
   * Filter, which Unit to fetch.
  **/
  where: UnitWhereUniqueInput
}


/**
 * Unit findMany
 */
export type FindManyUnitArgs = {
  /**
   * Select specific fields to fetch from the Unit
  **/
  select?: UnitSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UnitInclude | null
  /**
   * Filter, which Units to fetch.
  **/
  where?: UnitWhereInput
  /**
   * Determine the order of the Units to fetch.
  **/
  orderBy?: Enumerable<UnitOrderByInput>
  /**
   * Sets the position for listing Units.
  **/
  cursor?: UnitWhereUniqueInput
  /**
   * The number of Units to fetch. If negative number, it will take Units before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Units.
  **/
  skip?: number
  distinct?: Enumerable<UnitDistinctFieldEnum>
}


/**
 * Unit create
 */
export type UnitCreateArgs = {
  /**
   * Select specific fields to fetch from the Unit
  **/
  select?: UnitSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UnitInclude | null
  /**
   * The data needed to create a Unit.
  **/
  data: UnitCreateInput
}


/**
 * Unit update
 */
export type UnitUpdateArgs = {
  /**
   * Select specific fields to fetch from the Unit
  **/
  select?: UnitSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UnitInclude | null
  /**
   * The data needed to update a Unit.
  **/
  data: UnitUpdateInput
  /**
   * Choose, which Unit to update.
  **/
  where: UnitWhereUniqueInput
}


/**
 * Unit updateMany
 */
export type UnitUpdateManyArgs = {
  data: UnitUpdateManyMutationInput
  where?: UnitWhereInput
}


/**
 * Unit upsert
 */
export type UnitUpsertArgs = {
  /**
   * Select specific fields to fetch from the Unit
  **/
  select?: UnitSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UnitInclude | null
  /**
   * The filter to search for the Unit to update in case it exists.
  **/
  where: UnitWhereUniqueInput
  /**
   * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
  **/
  create: UnitCreateInput
  /**
   * In case the Unit was found with the provided `where` argument, update it with this data.
  **/
  update: UnitUpdateInput
}


/**
 * Unit delete
 */
export type UnitDeleteArgs = {
  /**
   * Select specific fields to fetch from the Unit
  **/
  select?: UnitSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UnitInclude | null
  /**
   * Filter which Unit to delete.
  **/
  where: UnitWhereUniqueInput
}


/**
 * Unit deleteMany
 */
export type UnitDeleteManyArgs = {
  where?: UnitWhereInput
}


/**
 * Unit without action
 */
export type UnitArgs = {
  /**
   * Select specific fields to fetch from the Unit
  **/
  select?: UnitSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UnitInclude | null
}



/**
 * Model Occupant
 */

export type Occupant = {
  id: number
  createdAt: Date
  name: string
  email: string
  phone: string
  unitId: number
}



export type OccupantSelect = {
  id?: boolean
  createdAt?: boolean
  name?: boolean
  email?: boolean
  phone?: boolean
  unit?: boolean | UnitArgs
  unitId?: boolean
}

export type OccupantInclude = {
  unit?: boolean | UnitArgs
}

export type OccupantGetPayload<
  S extends boolean | null | undefined | OccupantArgs,
  U = keyof S
> = S extends true
  ? Occupant
  : S extends undefined
  ? never
  : S extends OccupantArgs | FindManyOccupantArgs
  ? 'include' extends U
    ? Occupant  & {
      [P in TrueKeys<S['include']>]:
      P extends 'unit'
      ? UnitGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Occupant ? Occupant[P]
: 
      P extends 'unit'
      ? UnitGetPayload<S['select'][P]> : never
    }
  : Occupant
: Occupant


export interface OccupantDelegate {
  /**
   * Find zero or one Occupant.
   * @param {FindOneOccupantArgs} args - Arguments to find a Occupant
   * @example
   * // Get one Occupant
   * const occupant = await prisma.occupant.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneOccupantArgs>(
    args: Subset<T, FindOneOccupantArgs>
  ): CheckSelect<T, Prisma__OccupantClient<Occupant | null>, Prisma__OccupantClient<OccupantGetPayload<T> | null>>
  /**
   * Find zero or more Occupants.
   * @param {FindManyOccupantArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Occupants
   * const occupants = await prisma.occupant.findMany()
   * 
   * // Get first 10 Occupants
   * const occupants = await prisma.occupant.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const occupantWithIdOnly = await prisma.occupant.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyOccupantArgs>(
    args?: Subset<T, FindManyOccupantArgs>
  ): CheckSelect<T, Promise<Array<Occupant>>, Promise<Array<OccupantGetPayload<T>>>>
  /**
   * Create a Occupant.
   * @param {OccupantCreateArgs} args - Arguments to create a Occupant.
   * @example
   * // Create one Occupant
   * const Occupant = await prisma.occupant.create({
   *   data: {
   *     // ... data to create a Occupant
   *   }
   * })
   * 
  **/
  create<T extends OccupantCreateArgs>(
    args: Subset<T, OccupantCreateArgs>
  ): CheckSelect<T, Prisma__OccupantClient<Occupant>, Prisma__OccupantClient<OccupantGetPayload<T>>>
  /**
   * Delete a Occupant.
   * @param {OccupantDeleteArgs} args - Arguments to delete one Occupant.
   * @example
   * // Delete one Occupant
   * const Occupant = await prisma.occupant.delete({
   *   where: {
   *     // ... filter to delete one Occupant
   *   }
   * })
   * 
  **/
  delete<T extends OccupantDeleteArgs>(
    args: Subset<T, OccupantDeleteArgs>
  ): CheckSelect<T, Prisma__OccupantClient<Occupant>, Prisma__OccupantClient<OccupantGetPayload<T>>>
  /**
   * Update one Occupant.
   * @param {OccupantUpdateArgs} args - Arguments to update one Occupant.
   * @example
   * // Update one Occupant
   * const occupant = await prisma.occupant.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends OccupantUpdateArgs>(
    args: Subset<T, OccupantUpdateArgs>
  ): CheckSelect<T, Prisma__OccupantClient<Occupant>, Prisma__OccupantClient<OccupantGetPayload<T>>>
  /**
   * Delete zero or more Occupants.
   * @param {OccupantDeleteManyArgs} args - Arguments to filter Occupants to delete.
   * @example
   * // Delete a few Occupants
   * const { count } = await prisma.occupant.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends OccupantDeleteManyArgs>(
    args: Subset<T, OccupantDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Occupants.
   * @param {OccupantUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Occupants
   * const occupant = await prisma.occupant.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends OccupantUpdateManyArgs>(
    args: Subset<T, OccupantUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Occupant.
   * @param {OccupantUpsertArgs} args - Arguments to update or create a Occupant.
   * @example
   * // Update or create a Occupant
   * const occupant = await prisma.occupant.upsert({
   *   create: {
   *     // ... data to create a Occupant
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Occupant we want to update
   *   }
   * })
  **/
  upsert<T extends OccupantUpsertArgs>(
    args: Subset<T, OccupantUpsertArgs>
  ): CheckSelect<T, Prisma__OccupantClient<Occupant>, Prisma__OccupantClient<OccupantGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyOccupantArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Occupant.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__OccupantClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  unit<T extends UnitArgs = {}>(args?: Subset<T, UnitArgs>): CheckSelect<T, Prisma__UnitClient<Unit | null>, Prisma__UnitClient<UnitGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Occupant findOne
 */
export type FindOneOccupantArgs = {
  /**
   * Select specific fields to fetch from the Occupant
  **/
  select?: OccupantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OccupantInclude | null
  /**
   * Filter, which Occupant to fetch.
  **/
  where: OccupantWhereUniqueInput
}


/**
 * Occupant findMany
 */
export type FindManyOccupantArgs = {
  /**
   * Select specific fields to fetch from the Occupant
  **/
  select?: OccupantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OccupantInclude | null
  /**
   * Filter, which Occupants to fetch.
  **/
  where?: OccupantWhereInput
  /**
   * Determine the order of the Occupants to fetch.
  **/
  orderBy?: Enumerable<OccupantOrderByInput>
  /**
   * Sets the position for listing Occupants.
  **/
  cursor?: OccupantWhereUniqueInput
  /**
   * The number of Occupants to fetch. If negative number, it will take Occupants before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Occupants.
  **/
  skip?: number
  distinct?: Enumerable<OccupantDistinctFieldEnum>
}


/**
 * Occupant create
 */
export type OccupantCreateArgs = {
  /**
   * Select specific fields to fetch from the Occupant
  **/
  select?: OccupantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OccupantInclude | null
  /**
   * The data needed to create a Occupant.
  **/
  data: OccupantCreateInput
}


/**
 * Occupant update
 */
export type OccupantUpdateArgs = {
  /**
   * Select specific fields to fetch from the Occupant
  **/
  select?: OccupantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OccupantInclude | null
  /**
   * The data needed to update a Occupant.
  **/
  data: OccupantUpdateInput
  /**
   * Choose, which Occupant to update.
  **/
  where: OccupantWhereUniqueInput
}


/**
 * Occupant updateMany
 */
export type OccupantUpdateManyArgs = {
  data: OccupantUpdateManyMutationInput
  where?: OccupantWhereInput
}


/**
 * Occupant upsert
 */
export type OccupantUpsertArgs = {
  /**
   * Select specific fields to fetch from the Occupant
  **/
  select?: OccupantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OccupantInclude | null
  /**
   * The filter to search for the Occupant to update in case it exists.
  **/
  where: OccupantWhereUniqueInput
  /**
   * In case the Occupant found by the `where` argument doesn't exist, create a new Occupant with this data.
  **/
  create: OccupantCreateInput
  /**
   * In case the Occupant was found with the provided `where` argument, update it with this data.
  **/
  update: OccupantUpdateInput
}


/**
 * Occupant delete
 */
export type OccupantDeleteArgs = {
  /**
   * Select specific fields to fetch from the Occupant
  **/
  select?: OccupantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OccupantInclude | null
  /**
   * Filter which Occupant to delete.
  **/
  where: OccupantWhereUniqueInput
}


/**
 * Occupant deleteMany
 */
export type OccupantDeleteManyArgs = {
  where?: OccupantWhereInput
}


/**
 * Occupant without action
 */
export type OccupantArgs = {
  /**
   * Select specific fields to fetch from the Occupant
  **/
  select?: OccupantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OccupantInclude | null
}



/**
 * Model Lease
 */

export type Lease = {
  id: number
  createdAt: Date
  unitId: number
  term: Date | null
  amount: number | null
  extension: string | null
  notice: number | null
  showDate: Date
  security: string
  pdfLeaseSigned: string | null
  pdfLeaseUnsigned: string | null
  wordRider: string | null
}



export type LeaseSelect = {
  id?: boolean
  createdAt?: boolean
  unit?: boolean | UnitArgs
  unitId?: boolean
  term?: boolean
  amount?: boolean
  extension?: boolean
  notice?: boolean
  showDate?: boolean
  security?: boolean
  pdfLeaseSigned?: boolean
  pdfLeaseUnsigned?: boolean
  wordRider?: boolean
}

export type LeaseInclude = {
  unit?: boolean | UnitArgs
}

export type LeaseGetPayload<
  S extends boolean | null | undefined | LeaseArgs,
  U = keyof S
> = S extends true
  ? Lease
  : S extends undefined
  ? never
  : S extends LeaseArgs | FindManyLeaseArgs
  ? 'include' extends U
    ? Lease  & {
      [P in TrueKeys<S['include']>]:
      P extends 'unit'
      ? UnitGetPayload<S['include'][P]> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Lease ? Lease[P]
: 
      P extends 'unit'
      ? UnitGetPayload<S['select'][P]> : never
    }
  : Lease
: Lease


export interface LeaseDelegate {
  /**
   * Find zero or one Lease.
   * @param {FindOneLeaseArgs} args - Arguments to find a Lease
   * @example
   * // Get one Lease
   * const lease = await prisma.lease.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneLeaseArgs>(
    args: Subset<T, FindOneLeaseArgs>
  ): CheckSelect<T, Prisma__LeaseClient<Lease | null>, Prisma__LeaseClient<LeaseGetPayload<T> | null>>
  /**
   * Find zero or more Leases.
   * @param {FindManyLeaseArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Leases
   * const leases = await prisma.lease.findMany()
   * 
   * // Get first 10 Leases
   * const leases = await prisma.lease.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const leaseWithIdOnly = await prisma.lease.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyLeaseArgs>(
    args?: Subset<T, FindManyLeaseArgs>
  ): CheckSelect<T, Promise<Array<Lease>>, Promise<Array<LeaseGetPayload<T>>>>
  /**
   * Create a Lease.
   * @param {LeaseCreateArgs} args - Arguments to create a Lease.
   * @example
   * // Create one Lease
   * const Lease = await prisma.lease.create({
   *   data: {
   *     // ... data to create a Lease
   *   }
   * })
   * 
  **/
  create<T extends LeaseCreateArgs>(
    args: Subset<T, LeaseCreateArgs>
  ): CheckSelect<T, Prisma__LeaseClient<Lease>, Prisma__LeaseClient<LeaseGetPayload<T>>>
  /**
   * Delete a Lease.
   * @param {LeaseDeleteArgs} args - Arguments to delete one Lease.
   * @example
   * // Delete one Lease
   * const Lease = await prisma.lease.delete({
   *   where: {
   *     // ... filter to delete one Lease
   *   }
   * })
   * 
  **/
  delete<T extends LeaseDeleteArgs>(
    args: Subset<T, LeaseDeleteArgs>
  ): CheckSelect<T, Prisma__LeaseClient<Lease>, Prisma__LeaseClient<LeaseGetPayload<T>>>
  /**
   * Update one Lease.
   * @param {LeaseUpdateArgs} args - Arguments to update one Lease.
   * @example
   * // Update one Lease
   * const lease = await prisma.lease.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends LeaseUpdateArgs>(
    args: Subset<T, LeaseUpdateArgs>
  ): CheckSelect<T, Prisma__LeaseClient<Lease>, Prisma__LeaseClient<LeaseGetPayload<T>>>
  /**
   * Delete zero or more Leases.
   * @param {LeaseDeleteManyArgs} args - Arguments to filter Leases to delete.
   * @example
   * // Delete a few Leases
   * const { count } = await prisma.lease.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends LeaseDeleteManyArgs>(
    args: Subset<T, LeaseDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Leases.
   * @param {LeaseUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Leases
   * const lease = await prisma.lease.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends LeaseUpdateManyArgs>(
    args: Subset<T, LeaseUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Lease.
   * @param {LeaseUpsertArgs} args - Arguments to update or create a Lease.
   * @example
   * // Update or create a Lease
   * const lease = await prisma.lease.upsert({
   *   create: {
   *     // ... data to create a Lease
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Lease we want to update
   *   }
   * })
  **/
  upsert<T extends LeaseUpsertArgs>(
    args: Subset<T, LeaseUpsertArgs>
  ): CheckSelect<T, Prisma__LeaseClient<Lease>, Prisma__LeaseClient<LeaseGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyLeaseArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Lease.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__LeaseClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  unit<T extends UnitArgs = {}>(args?: Subset<T, UnitArgs>): CheckSelect<T, Prisma__UnitClient<Unit | null>, Prisma__UnitClient<UnitGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Lease findOne
 */
export type FindOneLeaseArgs = {
  /**
   * Select specific fields to fetch from the Lease
  **/
  select?: LeaseSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: LeaseInclude | null
  /**
   * Filter, which Lease to fetch.
  **/
  where: LeaseWhereUniqueInput
}


/**
 * Lease findMany
 */
export type FindManyLeaseArgs = {
  /**
   * Select specific fields to fetch from the Lease
  **/
  select?: LeaseSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: LeaseInclude | null
  /**
   * Filter, which Leases to fetch.
  **/
  where?: LeaseWhereInput
  /**
   * Determine the order of the Leases to fetch.
  **/
  orderBy?: Enumerable<LeaseOrderByInput>
  /**
   * Sets the position for listing Leases.
  **/
  cursor?: LeaseWhereUniqueInput
  /**
   * The number of Leases to fetch. If negative number, it will take Leases before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Leases.
  **/
  skip?: number
  distinct?: Enumerable<LeaseDistinctFieldEnum>
}


/**
 * Lease create
 */
export type LeaseCreateArgs = {
  /**
   * Select specific fields to fetch from the Lease
  **/
  select?: LeaseSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: LeaseInclude | null
  /**
   * The data needed to create a Lease.
  **/
  data: LeaseCreateInput
}


/**
 * Lease update
 */
export type LeaseUpdateArgs = {
  /**
   * Select specific fields to fetch from the Lease
  **/
  select?: LeaseSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: LeaseInclude | null
  /**
   * The data needed to update a Lease.
  **/
  data: LeaseUpdateInput
  /**
   * Choose, which Lease to update.
  **/
  where: LeaseWhereUniqueInput
}


/**
 * Lease updateMany
 */
export type LeaseUpdateManyArgs = {
  data: LeaseUpdateManyMutationInput
  where?: LeaseWhereInput
}


/**
 * Lease upsert
 */
export type LeaseUpsertArgs = {
  /**
   * Select specific fields to fetch from the Lease
  **/
  select?: LeaseSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: LeaseInclude | null
  /**
   * The filter to search for the Lease to update in case it exists.
  **/
  where: LeaseWhereUniqueInput
  /**
   * In case the Lease found by the `where` argument doesn't exist, create a new Lease with this data.
  **/
  create: LeaseCreateInput
  /**
   * In case the Lease was found with the provided `where` argument, update it with this data.
  **/
  update: LeaseUpdateInput
}


/**
 * Lease delete
 */
export type LeaseDeleteArgs = {
  /**
   * Select specific fields to fetch from the Lease
  **/
  select?: LeaseSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: LeaseInclude | null
  /**
   * Filter which Lease to delete.
  **/
  where: LeaseWhereUniqueInput
}


/**
 * Lease deleteMany
 */
export type LeaseDeleteManyArgs = {
  where?: LeaseWhereInput
}


/**
 * Lease without action
 */
export type LeaseArgs = {
  /**
   * Select specific fields to fetch from the Lease
  **/
  select?: LeaseSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: LeaseInclude | null
}



/**
 * Model SalesListing
 */

export type SalesListing = {
  id: number
  createdAt: Date
}



export type SalesListingSelect = {
  id?: boolean
  createdAt?: boolean
}

export type SalesListingGetPayload<
  S extends boolean | null | undefined | SalesListingArgs,
  U = keyof S
> = S extends true
  ? SalesListing
  : S extends undefined
  ? never
  : S extends SalesListingArgs | FindManySalesListingArgs
  ? 'include' extends U
    ? SalesListing 
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof SalesListing ? SalesListing[P]
: 
 never
    }
  : SalesListing
: SalesListing


export interface SalesListingDelegate {
  /**
   * Find zero or one SalesListing.
   * @param {FindOneSalesListingArgs} args - Arguments to find a SalesListing
   * @example
   * // Get one SalesListing
   * const salesListing = await prisma.salesListing.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneSalesListingArgs>(
    args: Subset<T, FindOneSalesListingArgs>
  ): CheckSelect<T, Prisma__SalesListingClient<SalesListing | null>, Prisma__SalesListingClient<SalesListingGetPayload<T> | null>>
  /**
   * Find zero or more SalesListings.
   * @param {FindManySalesListingArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all SalesListings
   * const salesListings = await prisma.salesListing.findMany()
   * 
   * // Get first 10 SalesListings
   * const salesListings = await prisma.salesListing.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const salesListingWithIdOnly = await prisma.salesListing.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManySalesListingArgs>(
    args?: Subset<T, FindManySalesListingArgs>
  ): CheckSelect<T, Promise<Array<SalesListing>>, Promise<Array<SalesListingGetPayload<T>>>>
  /**
   * Create a SalesListing.
   * @param {SalesListingCreateArgs} args - Arguments to create a SalesListing.
   * @example
   * // Create one SalesListing
   * const SalesListing = await prisma.salesListing.create({
   *   data: {
   *     // ... data to create a SalesListing
   *   }
   * })
   * 
  **/
  create<T extends SalesListingCreateArgs>(
    args: Subset<T, SalesListingCreateArgs>
  ): CheckSelect<T, Prisma__SalesListingClient<SalesListing>, Prisma__SalesListingClient<SalesListingGetPayload<T>>>
  /**
   * Delete a SalesListing.
   * @param {SalesListingDeleteArgs} args - Arguments to delete one SalesListing.
   * @example
   * // Delete one SalesListing
   * const SalesListing = await prisma.salesListing.delete({
   *   where: {
   *     // ... filter to delete one SalesListing
   *   }
   * })
   * 
  **/
  delete<T extends SalesListingDeleteArgs>(
    args: Subset<T, SalesListingDeleteArgs>
  ): CheckSelect<T, Prisma__SalesListingClient<SalesListing>, Prisma__SalesListingClient<SalesListingGetPayload<T>>>
  /**
   * Update one SalesListing.
   * @param {SalesListingUpdateArgs} args - Arguments to update one SalesListing.
   * @example
   * // Update one SalesListing
   * const salesListing = await prisma.salesListing.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends SalesListingUpdateArgs>(
    args: Subset<T, SalesListingUpdateArgs>
  ): CheckSelect<T, Prisma__SalesListingClient<SalesListing>, Prisma__SalesListingClient<SalesListingGetPayload<T>>>
  /**
   * Delete zero or more SalesListings.
   * @param {SalesListingDeleteManyArgs} args - Arguments to filter SalesListings to delete.
   * @example
   * // Delete a few SalesListings
   * const { count } = await prisma.salesListing.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends SalesListingDeleteManyArgs>(
    args: Subset<T, SalesListingDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more SalesListings.
   * @param {SalesListingUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many SalesListings
   * const salesListing = await prisma.salesListing.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends SalesListingUpdateManyArgs>(
    args: Subset<T, SalesListingUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one SalesListing.
   * @param {SalesListingUpsertArgs} args - Arguments to update or create a SalesListing.
   * @example
   * // Update or create a SalesListing
   * const salesListing = await prisma.salesListing.upsert({
   *   create: {
   *     // ... data to create a SalesListing
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the SalesListing we want to update
   *   }
   * })
  **/
  upsert<T extends SalesListingUpsertArgs>(
    args: Subset<T, SalesListingUpsertArgs>
  ): CheckSelect<T, Prisma__SalesListingClient<SalesListing>, Prisma__SalesListingClient<SalesListingGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManySalesListingArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for SalesListing.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__SalesListingClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';


  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * SalesListing findOne
 */
export type FindOneSalesListingArgs = {
  /**
   * Select specific fields to fetch from the SalesListing
  **/
  select?: SalesListingSelect | null
  /**
   * Filter, which SalesListing to fetch.
  **/
  where: SalesListingWhereUniqueInput
}


/**
 * SalesListing findMany
 */
export type FindManySalesListingArgs = {
  /**
   * Select specific fields to fetch from the SalesListing
  **/
  select?: SalesListingSelect | null
  /**
   * Filter, which SalesListings to fetch.
  **/
  where?: SalesListingWhereInput
  /**
   * Determine the order of the SalesListings to fetch.
  **/
  orderBy?: Enumerable<SalesListingOrderByInput>
  /**
   * Sets the position for listing SalesListings.
  **/
  cursor?: SalesListingWhereUniqueInput
  /**
   * The number of SalesListings to fetch. If negative number, it will take SalesListings before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` SalesListings.
  **/
  skip?: number
  distinct?: Enumerable<SalesListingDistinctFieldEnum>
}


/**
 * SalesListing create
 */
export type SalesListingCreateArgs = {
  /**
   * Select specific fields to fetch from the SalesListing
  **/
  select?: SalesListingSelect | null
  /**
   * The data needed to create a SalesListing.
  **/
  data: SalesListingCreateInput
}


/**
 * SalesListing update
 */
export type SalesListingUpdateArgs = {
  /**
   * Select specific fields to fetch from the SalesListing
  **/
  select?: SalesListingSelect | null
  /**
   * The data needed to update a SalesListing.
  **/
  data: SalesListingUpdateInput
  /**
   * Choose, which SalesListing to update.
  **/
  where: SalesListingWhereUniqueInput
}


/**
 * SalesListing updateMany
 */
export type SalesListingUpdateManyArgs = {
  data: SalesListingUpdateManyMutationInput
  where?: SalesListingWhereInput
}


/**
 * SalesListing upsert
 */
export type SalesListingUpsertArgs = {
  /**
   * Select specific fields to fetch from the SalesListing
  **/
  select?: SalesListingSelect | null
  /**
   * The filter to search for the SalesListing to update in case it exists.
  **/
  where: SalesListingWhereUniqueInput
  /**
   * In case the SalesListing found by the `where` argument doesn't exist, create a new SalesListing with this data.
  **/
  create: SalesListingCreateInput
  /**
   * In case the SalesListing was found with the provided `where` argument, update it with this data.
  **/
  update: SalesListingUpdateInput
}


/**
 * SalesListing delete
 */
export type SalesListingDeleteArgs = {
  /**
   * Select specific fields to fetch from the SalesListing
  **/
  select?: SalesListingSelect | null
  /**
   * Filter which SalesListing to delete.
  **/
  where: SalesListingWhereUniqueInput
}


/**
 * SalesListing deleteMany
 */
export type SalesListingDeleteManyArgs = {
  where?: SalesListingWhereInput
}


/**
 * SalesListing without action
 */
export type SalesListingArgs = {
  /**
   * Select specific fields to fetch from the SalesListing
  **/
  select?: SalesListingSelect | null
}



/**
 * Model ServiceHistory
 */

export type ServiceHistory = {
  id: number
  createdAt: Date
}



export type ServiceHistorySelect = {
  id?: boolean
  createdAt?: boolean
}

export type ServiceHistoryGetPayload<
  S extends boolean | null | undefined | ServiceHistoryArgs,
  U = keyof S
> = S extends true
  ? ServiceHistory
  : S extends undefined
  ? never
  : S extends ServiceHistoryArgs | FindManyServiceHistoryArgs
  ? 'include' extends U
    ? ServiceHistory 
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof ServiceHistory ? ServiceHistory[P]
: 
 never
    }
  : ServiceHistory
: ServiceHistory


export interface ServiceHistoryDelegate {
  /**
   * Find zero or one ServiceHistory.
   * @param {FindOneServiceHistoryArgs} args - Arguments to find a ServiceHistory
   * @example
   * // Get one ServiceHistory
   * const serviceHistory = await prisma.serviceHistory.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneServiceHistoryArgs>(
    args: Subset<T, FindOneServiceHistoryArgs>
  ): CheckSelect<T, Prisma__ServiceHistoryClient<ServiceHistory | null>, Prisma__ServiceHistoryClient<ServiceHistoryGetPayload<T> | null>>
  /**
   * Find zero or more ServiceHistories.
   * @param {FindManyServiceHistoryArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all ServiceHistories
   * const serviceHistories = await prisma.serviceHistory.findMany()
   * 
   * // Get first 10 ServiceHistories
   * const serviceHistories = await prisma.serviceHistory.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const serviceHistoryWithIdOnly = await prisma.serviceHistory.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyServiceHistoryArgs>(
    args?: Subset<T, FindManyServiceHistoryArgs>
  ): CheckSelect<T, Promise<Array<ServiceHistory>>, Promise<Array<ServiceHistoryGetPayload<T>>>>
  /**
   * Create a ServiceHistory.
   * @param {ServiceHistoryCreateArgs} args - Arguments to create a ServiceHistory.
   * @example
   * // Create one ServiceHistory
   * const ServiceHistory = await prisma.serviceHistory.create({
   *   data: {
   *     // ... data to create a ServiceHistory
   *   }
   * })
   * 
  **/
  create<T extends ServiceHistoryCreateArgs>(
    args: Subset<T, ServiceHistoryCreateArgs>
  ): CheckSelect<T, Prisma__ServiceHistoryClient<ServiceHistory>, Prisma__ServiceHistoryClient<ServiceHistoryGetPayload<T>>>
  /**
   * Delete a ServiceHistory.
   * @param {ServiceHistoryDeleteArgs} args - Arguments to delete one ServiceHistory.
   * @example
   * // Delete one ServiceHistory
   * const ServiceHistory = await prisma.serviceHistory.delete({
   *   where: {
   *     // ... filter to delete one ServiceHistory
   *   }
   * })
   * 
  **/
  delete<T extends ServiceHistoryDeleteArgs>(
    args: Subset<T, ServiceHistoryDeleteArgs>
  ): CheckSelect<T, Prisma__ServiceHistoryClient<ServiceHistory>, Prisma__ServiceHistoryClient<ServiceHistoryGetPayload<T>>>
  /**
   * Update one ServiceHistory.
   * @param {ServiceHistoryUpdateArgs} args - Arguments to update one ServiceHistory.
   * @example
   * // Update one ServiceHistory
   * const serviceHistory = await prisma.serviceHistory.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends ServiceHistoryUpdateArgs>(
    args: Subset<T, ServiceHistoryUpdateArgs>
  ): CheckSelect<T, Prisma__ServiceHistoryClient<ServiceHistory>, Prisma__ServiceHistoryClient<ServiceHistoryGetPayload<T>>>
  /**
   * Delete zero or more ServiceHistories.
   * @param {ServiceHistoryDeleteManyArgs} args - Arguments to filter ServiceHistories to delete.
   * @example
   * // Delete a few ServiceHistories
   * const { count } = await prisma.serviceHistory.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ServiceHistoryDeleteManyArgs>(
    args: Subset<T, ServiceHistoryDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more ServiceHistories.
   * @param {ServiceHistoryUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many ServiceHistories
   * const serviceHistory = await prisma.serviceHistory.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends ServiceHistoryUpdateManyArgs>(
    args: Subset<T, ServiceHistoryUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one ServiceHistory.
   * @param {ServiceHistoryUpsertArgs} args - Arguments to update or create a ServiceHistory.
   * @example
   * // Update or create a ServiceHistory
   * const serviceHistory = await prisma.serviceHistory.upsert({
   *   create: {
   *     // ... data to create a ServiceHistory
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the ServiceHistory we want to update
   *   }
   * })
  **/
  upsert<T extends ServiceHistoryUpsertArgs>(
    args: Subset<T, ServiceHistoryUpsertArgs>
  ): CheckSelect<T, Prisma__ServiceHistoryClient<ServiceHistory>, Prisma__ServiceHistoryClient<ServiceHistoryGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyServiceHistoryArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for ServiceHistory.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__ServiceHistoryClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';


  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * ServiceHistory findOne
 */
export type FindOneServiceHistoryArgs = {
  /**
   * Select specific fields to fetch from the ServiceHistory
  **/
  select?: ServiceHistorySelect | null
  /**
   * Filter, which ServiceHistory to fetch.
  **/
  where: ServiceHistoryWhereUniqueInput
}


/**
 * ServiceHistory findMany
 */
export type FindManyServiceHistoryArgs = {
  /**
   * Select specific fields to fetch from the ServiceHistory
  **/
  select?: ServiceHistorySelect | null
  /**
   * Filter, which ServiceHistories to fetch.
  **/
  where?: ServiceHistoryWhereInput
  /**
   * Determine the order of the ServiceHistories to fetch.
  **/
  orderBy?: Enumerable<ServiceHistoryOrderByInput>
  /**
   * Sets the position for listing ServiceHistories.
  **/
  cursor?: ServiceHistoryWhereUniqueInput
  /**
   * The number of ServiceHistories to fetch. If negative number, it will take ServiceHistories before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` ServiceHistories.
  **/
  skip?: number
  distinct?: Enumerable<ServiceHistoryDistinctFieldEnum>
}


/**
 * ServiceHistory create
 */
export type ServiceHistoryCreateArgs = {
  /**
   * Select specific fields to fetch from the ServiceHistory
  **/
  select?: ServiceHistorySelect | null
  /**
   * The data needed to create a ServiceHistory.
  **/
  data: ServiceHistoryCreateInput
}


/**
 * ServiceHistory update
 */
export type ServiceHistoryUpdateArgs = {
  /**
   * Select specific fields to fetch from the ServiceHistory
  **/
  select?: ServiceHistorySelect | null
  /**
   * The data needed to update a ServiceHistory.
  **/
  data: ServiceHistoryUpdateInput
  /**
   * Choose, which ServiceHistory to update.
  **/
  where: ServiceHistoryWhereUniqueInput
}


/**
 * ServiceHistory updateMany
 */
export type ServiceHistoryUpdateManyArgs = {
  data: ServiceHistoryUpdateManyMutationInput
  where?: ServiceHistoryWhereInput
}


/**
 * ServiceHistory upsert
 */
export type ServiceHistoryUpsertArgs = {
  /**
   * Select specific fields to fetch from the ServiceHistory
  **/
  select?: ServiceHistorySelect | null
  /**
   * The filter to search for the ServiceHistory to update in case it exists.
  **/
  where: ServiceHistoryWhereUniqueInput
  /**
   * In case the ServiceHistory found by the `where` argument doesn't exist, create a new ServiceHistory with this data.
  **/
  create: ServiceHistoryCreateInput
  /**
   * In case the ServiceHistory was found with the provided `where` argument, update it with this data.
  **/
  update: ServiceHistoryUpdateInput
}


/**
 * ServiceHistory delete
 */
export type ServiceHistoryDeleteArgs = {
  /**
   * Select specific fields to fetch from the ServiceHistory
  **/
  select?: ServiceHistorySelect | null
  /**
   * Filter which ServiceHistory to delete.
  **/
  where: ServiceHistoryWhereUniqueInput
}


/**
 * ServiceHistory deleteMany
 */
export type ServiceHistoryDeleteManyArgs = {
  where?: ServiceHistoryWhereInput
}


/**
 * ServiceHistory without action
 */
export type ServiceHistoryArgs = {
  /**
   * Select specific fields to fetch from the ServiceHistory
  **/
  select?: ServiceHistorySelect | null
}



/**
 * Model ServiceCompany
 */

export type ServiceCompany = {
  id: number
  createdAt: Date
}



export type ServiceCompanySelect = {
  id?: boolean
  createdAt?: boolean
}

export type ServiceCompanyGetPayload<
  S extends boolean | null | undefined | ServiceCompanyArgs,
  U = keyof S
> = S extends true
  ? ServiceCompany
  : S extends undefined
  ? never
  : S extends ServiceCompanyArgs | FindManyServiceCompanyArgs
  ? 'include' extends U
    ? ServiceCompany 
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof ServiceCompany ? ServiceCompany[P]
: 
 never
    }
  : ServiceCompany
: ServiceCompany


export interface ServiceCompanyDelegate {
  /**
   * Find zero or one ServiceCompany.
   * @param {FindOneServiceCompanyArgs} args - Arguments to find a ServiceCompany
   * @example
   * // Get one ServiceCompany
   * const serviceCompany = await prisma.serviceCompany.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneServiceCompanyArgs>(
    args: Subset<T, FindOneServiceCompanyArgs>
  ): CheckSelect<T, Prisma__ServiceCompanyClient<ServiceCompany | null>, Prisma__ServiceCompanyClient<ServiceCompanyGetPayload<T> | null>>
  /**
   * Find zero or more ServiceCompanies.
   * @param {FindManyServiceCompanyArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all ServiceCompanies
   * const serviceCompanies = await prisma.serviceCompany.findMany()
   * 
   * // Get first 10 ServiceCompanies
   * const serviceCompanies = await prisma.serviceCompany.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const serviceCompanyWithIdOnly = await prisma.serviceCompany.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyServiceCompanyArgs>(
    args?: Subset<T, FindManyServiceCompanyArgs>
  ): CheckSelect<T, Promise<Array<ServiceCompany>>, Promise<Array<ServiceCompanyGetPayload<T>>>>
  /**
   * Create a ServiceCompany.
   * @param {ServiceCompanyCreateArgs} args - Arguments to create a ServiceCompany.
   * @example
   * // Create one ServiceCompany
   * const ServiceCompany = await prisma.serviceCompany.create({
   *   data: {
   *     // ... data to create a ServiceCompany
   *   }
   * })
   * 
  **/
  create<T extends ServiceCompanyCreateArgs>(
    args: Subset<T, ServiceCompanyCreateArgs>
  ): CheckSelect<T, Prisma__ServiceCompanyClient<ServiceCompany>, Prisma__ServiceCompanyClient<ServiceCompanyGetPayload<T>>>
  /**
   * Delete a ServiceCompany.
   * @param {ServiceCompanyDeleteArgs} args - Arguments to delete one ServiceCompany.
   * @example
   * // Delete one ServiceCompany
   * const ServiceCompany = await prisma.serviceCompany.delete({
   *   where: {
   *     // ... filter to delete one ServiceCompany
   *   }
   * })
   * 
  **/
  delete<T extends ServiceCompanyDeleteArgs>(
    args: Subset<T, ServiceCompanyDeleteArgs>
  ): CheckSelect<T, Prisma__ServiceCompanyClient<ServiceCompany>, Prisma__ServiceCompanyClient<ServiceCompanyGetPayload<T>>>
  /**
   * Update one ServiceCompany.
   * @param {ServiceCompanyUpdateArgs} args - Arguments to update one ServiceCompany.
   * @example
   * // Update one ServiceCompany
   * const serviceCompany = await prisma.serviceCompany.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends ServiceCompanyUpdateArgs>(
    args: Subset<T, ServiceCompanyUpdateArgs>
  ): CheckSelect<T, Prisma__ServiceCompanyClient<ServiceCompany>, Prisma__ServiceCompanyClient<ServiceCompanyGetPayload<T>>>
  /**
   * Delete zero or more ServiceCompanies.
   * @param {ServiceCompanyDeleteManyArgs} args - Arguments to filter ServiceCompanies to delete.
   * @example
   * // Delete a few ServiceCompanies
   * const { count } = await prisma.serviceCompany.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ServiceCompanyDeleteManyArgs>(
    args: Subset<T, ServiceCompanyDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more ServiceCompanies.
   * @param {ServiceCompanyUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many ServiceCompanies
   * const serviceCompany = await prisma.serviceCompany.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends ServiceCompanyUpdateManyArgs>(
    args: Subset<T, ServiceCompanyUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one ServiceCompany.
   * @param {ServiceCompanyUpsertArgs} args - Arguments to update or create a ServiceCompany.
   * @example
   * // Update or create a ServiceCompany
   * const serviceCompany = await prisma.serviceCompany.upsert({
   *   create: {
   *     // ... data to create a ServiceCompany
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the ServiceCompany we want to update
   *   }
   * })
  **/
  upsert<T extends ServiceCompanyUpsertArgs>(
    args: Subset<T, ServiceCompanyUpsertArgs>
  ): CheckSelect<T, Prisma__ServiceCompanyClient<ServiceCompany>, Prisma__ServiceCompanyClient<ServiceCompanyGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyServiceCompanyArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for ServiceCompany.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__ServiceCompanyClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';


  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * ServiceCompany findOne
 */
export type FindOneServiceCompanyArgs = {
  /**
   * Select specific fields to fetch from the ServiceCompany
  **/
  select?: ServiceCompanySelect | null
  /**
   * Filter, which ServiceCompany to fetch.
  **/
  where: ServiceCompanyWhereUniqueInput
}


/**
 * ServiceCompany findMany
 */
export type FindManyServiceCompanyArgs = {
  /**
   * Select specific fields to fetch from the ServiceCompany
  **/
  select?: ServiceCompanySelect | null
  /**
   * Filter, which ServiceCompanies to fetch.
  **/
  where?: ServiceCompanyWhereInput
  /**
   * Determine the order of the ServiceCompanies to fetch.
  **/
  orderBy?: Enumerable<ServiceCompanyOrderByInput>
  /**
   * Sets the position for listing ServiceCompanies.
  **/
  cursor?: ServiceCompanyWhereUniqueInput
  /**
   * The number of ServiceCompanies to fetch. If negative number, it will take ServiceCompanies before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` ServiceCompanies.
  **/
  skip?: number
  distinct?: Enumerable<ServiceCompanyDistinctFieldEnum>
}


/**
 * ServiceCompany create
 */
export type ServiceCompanyCreateArgs = {
  /**
   * Select specific fields to fetch from the ServiceCompany
  **/
  select?: ServiceCompanySelect | null
  /**
   * The data needed to create a ServiceCompany.
  **/
  data: ServiceCompanyCreateInput
}


/**
 * ServiceCompany update
 */
export type ServiceCompanyUpdateArgs = {
  /**
   * Select specific fields to fetch from the ServiceCompany
  **/
  select?: ServiceCompanySelect | null
  /**
   * The data needed to update a ServiceCompany.
  **/
  data: ServiceCompanyUpdateInput
  /**
   * Choose, which ServiceCompany to update.
  **/
  where: ServiceCompanyWhereUniqueInput
}


/**
 * ServiceCompany updateMany
 */
export type ServiceCompanyUpdateManyArgs = {
  data: ServiceCompanyUpdateManyMutationInput
  where?: ServiceCompanyWhereInput
}


/**
 * ServiceCompany upsert
 */
export type ServiceCompanyUpsertArgs = {
  /**
   * Select specific fields to fetch from the ServiceCompany
  **/
  select?: ServiceCompanySelect | null
  /**
   * The filter to search for the ServiceCompany to update in case it exists.
  **/
  where: ServiceCompanyWhereUniqueInput
  /**
   * In case the ServiceCompany found by the `where` argument doesn't exist, create a new ServiceCompany with this data.
  **/
  create: ServiceCompanyCreateInput
  /**
   * In case the ServiceCompany was found with the provided `where` argument, update it with this data.
  **/
  update: ServiceCompanyUpdateInput
}


/**
 * ServiceCompany delete
 */
export type ServiceCompanyDeleteArgs = {
  /**
   * Select specific fields to fetch from the ServiceCompany
  **/
  select?: ServiceCompanySelect | null
  /**
   * Filter which ServiceCompany to delete.
  **/
  where: ServiceCompanyWhereUniqueInput
}


/**
 * ServiceCompany deleteMany
 */
export type ServiceCompanyDeleteManyArgs = {
  where?: ServiceCompanyWhereInput
}


/**
 * ServiceCompany without action
 */
export type ServiceCompanyArgs = {
  /**
   * Select specific fields to fetch from the ServiceCompany
  **/
  select?: ServiceCompanySelect | null
}



/**
 * Deep Input Types
 */


export type OwnerWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  name?: string | StringFilter
  address?: string | StringFilter
  phone?: string | NullableStringFilter | null
  email?: string | NullableStringFilter | null
  units?: UnitFilter | null
  notes?: string | NullableStringFilter | null
  AND?: Enumerable<OwnerWhereInput>
  OR?: Array<OwnerWhereInput>
  NOT?: Enumerable<OwnerWhereInput>
}

export type OwnerOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  name?: SortOrder
  address?: SortOrder
  phone?: SortOrder
  email?: SortOrder
  notes?: SortOrder
}

export type OwnerWhereUniqueInput = {
  id?: number
  phone?: string | null
  email?: string | null
}

export type TenantWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  name?: string | StringFilter
  address?: string | StringFilter
  phone?: string | NullableStringFilter | null
  email?: string | NullableStringFilter | null
  unitId?: number | NullableIntFilter | null
  notes?: string | NullableStringFilter | null
  AND?: Enumerable<TenantWhereInput>
  OR?: Array<TenantWhereInput>
  NOT?: Enumerable<TenantWhereInput>
  unit?: UnitRelationFilter
}

export type TenantOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  name?: SortOrder
  address?: SortOrder
  phone?: SortOrder
  email?: SortOrder
  unitId?: SortOrder
  notes?: SortOrder
}

export type TenantWhereUniqueInput = {
  id?: number
  phone?: string | null
  email?: string | null
}

export type AgentWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  name?: string | StringFilter
  email?: string | StringFilter
  password?: string | StringFilter
  phone?: string | StringFilter
  altPhone?: string | StringFilter
  units?: UnitFilter | null
  AND?: Enumerable<AgentWhereInput>
  OR?: Array<AgentWhereInput>
  NOT?: Enumerable<AgentWhereInput>
}

export type AgentOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  name?: SortOrder
  email?: SortOrder
  password?: SortOrder
  phone?: SortOrder
  altPhone?: SortOrder
}

export type AgentWhereUniqueInput = {
  id?: number
  email?: string
  phone?: string
}

export type BuildingWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  address?: string | StringFilter
  name?: string | NullableStringFilter | null
  phone?: string | StringFilter
  email?: string | StringFilter
  units?: UnitFilter | null
  notes?: string | StringFilter
  insurance?: string | StringFilter
  boardPackages?: string | StringFilter
  salesapplication?: string | StringFilter
  salesPackage?: string | StringFilter
  specialDocuments?: string | StringFilter
  AND?: Enumerable<BuildingWhereInput>
  OR?: Array<BuildingWhereInput>
  NOT?: Enumerable<BuildingWhereInput>
}

export type BuildingOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  address?: SortOrder
  name?: SortOrder
  phone?: SortOrder
  email?: SortOrder
  notes?: SortOrder
  insurance?: SortOrder
  boardPackages?: SortOrder
  salesapplication?: SortOrder
  salesPackage?: SortOrder
  specialDocuments?: SortOrder
}

export type BuildingWhereUniqueInput = {
  id?: number
}

export type UnitWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  buildingId?: number | IntFilter
  apt?: string | StringFilter
  sale?: boolean | BooleanFilter
  agent?: AgentFilter | null
  owner?: OwnerFilter | null
  tenant?: TenantFilter | null
  pets?: boolean | NullableBooleanFilter | null
  dogBreed?: string | NullableStringFilter | null
  storageL?: boolean | NullableBooleanFilter | null
  storageB?: boolean | NullableBooleanFilter | null
  advertisement?: string | StringFilter
  occupants?: OccupantFilter | null
  floorplan?: string | NullableStringFilter | null
  sqft?: number | NullableFloatFilter | null
  purchasePrice?: number | NullableFloatFilter | null
  insurance?: string | NullableStringFilter | null
  tenantInsurance?: string | NullableStringFilter | null
  AND?: Enumerable<UnitWhereInput>
  OR?: Array<UnitWhereInput>
  NOT?: Enumerable<UnitWhereInput>
  building?: BuildingRelationFilter
  lease?: LeaseRelationFilter
}

export type UnitOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  buildingId?: SortOrder
  apt?: SortOrder
  sale?: SortOrder
  pets?: SortOrder
  dogBreed?: SortOrder
  storageL?: SortOrder
  storageB?: SortOrder
  advertisement?: SortOrder
  floorplan?: SortOrder
  sqft?: SortOrder
  purchasePrice?: SortOrder
  insurance?: SortOrder
  tenantInsurance?: SortOrder
}

export type UnitWhereUniqueInput = {
  id?: number
}

export type OccupantWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  name?: string | StringFilter
  email?: string | StringFilter
  phone?: string | StringFilter
  unitId?: number | IntFilter
  AND?: Enumerable<OccupantWhereInput>
  OR?: Array<OccupantWhereInput>
  NOT?: Enumerable<OccupantWhereInput>
  unit?: UnitRelationFilter
}

export type OccupantOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  name?: SortOrder
  email?: SortOrder
  phone?: SortOrder
  unitId?: SortOrder
}

export type OccupantWhereUniqueInput = {
  id?: number
}

export type LeaseWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  unitId?: number | IntFilter
  term?: Date | string | NullableDateTimeFilter | null
  amount?: number | NullableFloatFilter | null
  extension?: string | NullableStringFilter | null
  notice?: number | NullableIntFilter | null
  showDate?: Date | string | DateTimeFilter
  security?: string | StringFilter
  pdfLeaseSigned?: string | NullableStringFilter | null
  pdfLeaseUnsigned?: string | NullableStringFilter | null
  wordRider?: string | NullableStringFilter | null
  AND?: Enumerable<LeaseWhereInput>
  OR?: Array<LeaseWhereInput>
  NOT?: Enumerable<LeaseWhereInput>
  unit?: UnitRelationFilter
}

export type LeaseOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  unitId?: SortOrder
  term?: SortOrder
  amount?: SortOrder
  extension?: SortOrder
  notice?: SortOrder
  showDate?: SortOrder
  security?: SortOrder
  pdfLeaseSigned?: SortOrder
  pdfLeaseUnsigned?: SortOrder
  wordRider?: SortOrder
}

export type LeaseWhereUniqueInput = {
  id?: number
}

export type SalesListingWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  AND?: Enumerable<SalesListingWhereInput>
  OR?: Array<SalesListingWhereInput>
  NOT?: Enumerable<SalesListingWhereInput>
}

export type SalesListingOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
}

export type SalesListingWhereUniqueInput = {
  id?: number
}

export type ServiceHistoryWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  AND?: Enumerable<ServiceHistoryWhereInput>
  OR?: Array<ServiceHistoryWhereInput>
  NOT?: Enumerable<ServiceHistoryWhereInput>
}

export type ServiceHistoryOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
}

export type ServiceHistoryWhereUniqueInput = {
  id?: number
}

export type ServiceCompanyWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  AND?: Enumerable<ServiceCompanyWhereInput>
  OR?: Array<ServiceCompanyWhereInput>
  NOT?: Enumerable<ServiceCompanyWhereInput>
}

export type ServiceCompanyOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
}

export type ServiceCompanyWhereUniqueInput = {
  id?: number
}

export type OwnerCreateInput = {
  createdAt?: Date | string
  name: string
  address: string
  phone?: string | null
  email?: string | null
  notes?: string | null
  units?: UnitCreateManyWithoutOwnerInput
}

export type OwnerUpdateInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  name?: StringFieldUpdateOperationsInput
  address?: StringFieldUpdateOperationsInput
  phone?: NullableStringFieldUpdateOperationsInput
  email?: NullableStringFieldUpdateOperationsInput
  notes?: NullableStringFieldUpdateOperationsInput
  units?: UnitUpdateManyWithoutOwnerInput
}

export type OwnerUpdateManyMutationInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  name?: StringFieldUpdateOperationsInput
  address?: StringFieldUpdateOperationsInput
  phone?: NullableStringFieldUpdateOperationsInput
  email?: NullableStringFieldUpdateOperationsInput
  notes?: NullableStringFieldUpdateOperationsInput
}

export type TenantCreateInput = {
  createdAt?: Date | string
  name: string
  address: string
  phone?: string | null
  email?: string | null
  notes?: string | null
  unit?: UnitCreateOneWithoutTenantInput
}

export type TenantUpdateInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  name?: StringFieldUpdateOperationsInput
  address?: StringFieldUpdateOperationsInput
  phone?: NullableStringFieldUpdateOperationsInput
  email?: NullableStringFieldUpdateOperationsInput
  notes?: NullableStringFieldUpdateOperationsInput
  unit?: UnitUpdateOneWithoutTenantInput
}

export type TenantUpdateManyMutationInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  name?: StringFieldUpdateOperationsInput
  address?: StringFieldUpdateOperationsInput
  phone?: NullableStringFieldUpdateOperationsInput
  email?: NullableStringFieldUpdateOperationsInput
  notes?: NullableStringFieldUpdateOperationsInput
}

export type AgentCreateInput = {
  createdAt?: Date | string
  name: string
  email: string
  password: string
  phone: string
  altPhone: string
  units?: UnitCreateManyWithoutAgentInput
}

export type AgentUpdateInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  name?: StringFieldUpdateOperationsInput
  email?: StringFieldUpdateOperationsInput
  password?: StringFieldUpdateOperationsInput
  phone?: StringFieldUpdateOperationsInput
  altPhone?: StringFieldUpdateOperationsInput
  units?: UnitUpdateManyWithoutAgentInput
}

export type AgentUpdateManyMutationInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  name?: StringFieldUpdateOperationsInput
  email?: StringFieldUpdateOperationsInput
  password?: StringFieldUpdateOperationsInput
  phone?: StringFieldUpdateOperationsInput
  altPhone?: StringFieldUpdateOperationsInput
}

export type BuildingCreateInput = {
  createdAt?: Date | string
  address: string
  name?: string | null
  phone: string
  email: string
  notes: string
  insurance: string
  boardPackages: string
  salesapplication: string
  salesPackage: string
  specialDocuments: string
  units?: UnitCreateManyWithoutBuildingInput
}

export type BuildingUpdateInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  address?: StringFieldUpdateOperationsInput
  name?: NullableStringFieldUpdateOperationsInput
  phone?: StringFieldUpdateOperationsInput
  email?: StringFieldUpdateOperationsInput
  notes?: StringFieldUpdateOperationsInput
  insurance?: StringFieldUpdateOperationsInput
  boardPackages?: StringFieldUpdateOperationsInput
  salesapplication?: StringFieldUpdateOperationsInput
  salesPackage?: StringFieldUpdateOperationsInput
  specialDocuments?: StringFieldUpdateOperationsInput
  units?: UnitUpdateManyWithoutBuildingInput
}

export type BuildingUpdateManyMutationInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  address?: StringFieldUpdateOperationsInput
  name?: NullableStringFieldUpdateOperationsInput
  phone?: StringFieldUpdateOperationsInput
  email?: StringFieldUpdateOperationsInput
  notes?: StringFieldUpdateOperationsInput
  insurance?: StringFieldUpdateOperationsInput
  boardPackages?: StringFieldUpdateOperationsInput
  salesapplication?: StringFieldUpdateOperationsInput
  salesPackage?: StringFieldUpdateOperationsInput
  specialDocuments?: StringFieldUpdateOperationsInput
}

export type UnitCreateInput = {
  createdAt?: Date | string
  apt: string
  sale: boolean
  pets?: boolean | null
  dogBreed?: string | null
  storageL?: boolean | null
  storageB?: boolean | null
  advertisement: string
  floorplan?: string | null
  sqft?: number | null
  purchasePrice?: number | null
  insurance?: string | null
  tenantInsurance?: string | null
  agent?: AgentCreateManyWithoutUnitsInput
  building: BuildingCreateOneWithoutUnitsInput
  owner?: OwnerCreateManyWithoutUnitsInput
  tenant?: TenantCreateManyWithoutUnitInput
  lease?: LeaseCreateOneWithoutUnitInput
  occupants?: OccupantCreateManyWithoutUnitInput
}

export type UnitUpdateInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  apt?: StringFieldUpdateOperationsInput
  sale?: BoolFieldUpdateOperationsInput
  pets?: NullableBoolFieldUpdateOperationsInput
  dogBreed?: NullableStringFieldUpdateOperationsInput
  storageL?: NullableBoolFieldUpdateOperationsInput
  storageB?: NullableBoolFieldUpdateOperationsInput
  advertisement?: StringFieldUpdateOperationsInput
  floorplan?: NullableStringFieldUpdateOperationsInput
  sqft?: NullableFloatFieldUpdateOperationsInput
  purchasePrice?: NullableFloatFieldUpdateOperationsInput
  insurance?: NullableStringFieldUpdateOperationsInput
  tenantInsurance?: NullableStringFieldUpdateOperationsInput
  agent?: AgentUpdateManyWithoutUnitsInput
  building?: BuildingUpdateOneRequiredWithoutUnitsInput
  owner?: OwnerUpdateManyWithoutUnitsInput
  tenant?: TenantUpdateManyWithoutUnitInput
  lease?: LeaseUpdateOneRequiredWithoutUnitInput
  occupants?: OccupantUpdateManyWithoutUnitInput
}

export type UnitUpdateManyMutationInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  apt?: StringFieldUpdateOperationsInput
  sale?: BoolFieldUpdateOperationsInput
  pets?: NullableBoolFieldUpdateOperationsInput
  dogBreed?: NullableStringFieldUpdateOperationsInput
  storageL?: NullableBoolFieldUpdateOperationsInput
  storageB?: NullableBoolFieldUpdateOperationsInput
  advertisement?: StringFieldUpdateOperationsInput
  floorplan?: NullableStringFieldUpdateOperationsInput
  sqft?: NullableFloatFieldUpdateOperationsInput
  purchasePrice?: NullableFloatFieldUpdateOperationsInput
  insurance?: NullableStringFieldUpdateOperationsInput
  tenantInsurance?: NullableStringFieldUpdateOperationsInput
}

export type OccupantCreateInput = {
  createdAt?: Date | string
  name: string
  email: string
  phone: string
  unit: UnitCreateOneWithoutOccupantsInput
}

export type OccupantUpdateInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  name?: StringFieldUpdateOperationsInput
  email?: StringFieldUpdateOperationsInput
  phone?: StringFieldUpdateOperationsInput
  unit?: UnitUpdateOneRequiredWithoutOccupantsInput
}

export type OccupantUpdateManyMutationInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  name?: StringFieldUpdateOperationsInput
  email?: StringFieldUpdateOperationsInput
  phone?: StringFieldUpdateOperationsInput
}

export type LeaseCreateInput = {
  createdAt?: Date | string
  term?: Date | string | null
  amount?: number | null
  extension?: string | null
  notice?: number | null
  showDate: Date | string
  security: string
  pdfLeaseSigned?: string | null
  pdfLeaseUnsigned?: string | null
  wordRider?: string | null
  unit: UnitCreateOneWithoutLeaseInput
}

export type LeaseUpdateInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  term?: NullableDateTimeFieldUpdateOperationsInput
  amount?: NullableFloatFieldUpdateOperationsInput
  extension?: NullableStringFieldUpdateOperationsInput
  notice?: NullableIntFieldUpdateOperationsInput
  showDate?: DateTimeFieldUpdateOperationsInput
  security?: StringFieldUpdateOperationsInput
  pdfLeaseSigned?: NullableStringFieldUpdateOperationsInput
  pdfLeaseUnsigned?: NullableStringFieldUpdateOperationsInput
  wordRider?: NullableStringFieldUpdateOperationsInput
  unit?: UnitUpdateOneRequiredWithoutLeaseInput
}

export type LeaseUpdateManyMutationInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  term?: NullableDateTimeFieldUpdateOperationsInput
  amount?: NullableFloatFieldUpdateOperationsInput
  extension?: NullableStringFieldUpdateOperationsInput
  notice?: NullableIntFieldUpdateOperationsInput
  showDate?: DateTimeFieldUpdateOperationsInput
  security?: StringFieldUpdateOperationsInput
  pdfLeaseSigned?: NullableStringFieldUpdateOperationsInput
  pdfLeaseUnsigned?: NullableStringFieldUpdateOperationsInput
  wordRider?: NullableStringFieldUpdateOperationsInput
}

export type SalesListingCreateInput = {
  createdAt?: Date | string
}

export type SalesListingUpdateInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
}

export type SalesListingUpdateManyMutationInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
}

export type ServiceHistoryCreateInput = {
  createdAt?: Date | string
}

export type ServiceHistoryUpdateInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
}

export type ServiceHistoryUpdateManyMutationInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
}

export type ServiceCompanyCreateInput = {
  createdAt?: Date | string
}

export type ServiceCompanyUpdateInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
}

export type ServiceCompanyUpdateManyMutationInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
}

export type IntFilter = {
  equals?: number
  not?: number | IntFilter
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
}

export type DateTimeFilter = {
  equals?: Date | string
  not?: Date | string | DateTimeFilter
  in?: Enumerable<Date | string>
  notIn?: Enumerable<Date | string>
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
}

export type StringFilter = {
  equals?: string
  not?: string | StringFilter
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
}

export type StringNullableFilter = {
  equals?: string | null
  in?: Enumerable<string> | null
  lt?: string | null
  lte?: string | null
  gt?: string | null
  gte?: string | null
  contains?: string | null
  startsWith?: string | null
  endsWith?: string | null
  not?: NestedStringNullableFilter | null
}

export type UnitListRelationFilter = {
  every?: UnitWhereInput
  some?: UnitWhereInput
  none?: UnitWhereInput
}

export type UnitRelationFilter = {
  is?: UnitWhereInput | null
  isNot?: UnitWhereInput | null
}

export type IntNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  lt?: number | null
  lte?: number | null
  gt?: number | null
  gte?: number | null
  not?: NestedIntNullableFilter | null
}

export type BoolFilter = {
  equals?: boolean
  not?: NestedBoolFilter | null
}

export type AgentListRelationFilter = {
  every?: AgentWhereInput
  some?: AgentWhereInput
  none?: AgentWhereInput
}

export type BuildingRelationFilter = {
  is?: BuildingWhereInput | null
  isNot?: BuildingWhereInput | null
}

export type OwnerListRelationFilter = {
  every?: OwnerWhereInput
  some?: OwnerWhereInput
  none?: OwnerWhereInput
}

export type TenantListRelationFilter = {
  every?: TenantWhereInput
  some?: TenantWhereInput
  none?: TenantWhereInput
}

export type LeaseRelationFilter = {
  is?: LeaseWhereInput | null
  isNot?: LeaseWhereInput | null
}

export type BoolNullableFilter = {
  equals?: boolean | null
  not?: NestedBoolNullableFilter | null
}

export type OccupantListRelationFilter = {
  every?: OccupantWhereInput
  some?: OccupantWhereInput
  none?: OccupantWhereInput
}

export type FloatNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  lt?: number | null
  lte?: number | null
  gt?: number | null
  gte?: number | null
  not?: NestedFloatNullableFilter | null
}

export type DateTimeNullableFilter = {
  equals?: Date | string | null
  in?: Enumerable<Date | string> | null
  lt?: Date | string | null
  lte?: Date | string | null
  gt?: Date | string | null
  gte?: Date | string | null
  not?: NestedDateTimeNullableFilter | null
}

export type UnitCreateManyWithoutOwnerInput = {
  create?: Enumerable<UnitCreateWithoutOwnerInput>
  connect?: Enumerable<UnitWhereUniqueInput>
  connectOrCreate?: Enumerable<UnitCreateOrConnectWithoutOwnerInput>
}

export type DateTimeFieldUpdateOperationsInput = {
  set?: Date | string
}

export type StringFieldUpdateOperationsInput = {
  set?: string
}

export type NullableStringFieldUpdateOperationsInput = {
  set?: string | null
}

export type UnitUpdateManyWithoutOwnerInput = {
  create?: Enumerable<UnitCreateWithoutOwnerInput>
  connect?: Enumerable<UnitWhereUniqueInput>
  set?: Enumerable<UnitWhereUniqueInput>
  disconnect?: Enumerable<UnitWhereUniqueInput>
  delete?: Enumerable<UnitWhereUniqueInput>
  update?: Enumerable<UnitUpdateWithWhereUniqueWithoutOwnerInput>
  updateMany?: Enumerable<UnitUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<UnitScalarWhereInput>
  upsert?: Enumerable<UnitUpsertWithWhereUniqueWithoutOwnerInput>
  connectOrCreate?: Enumerable<UnitCreateOrConnectWithoutOwnerInput>
}

export type UnitCreateOneWithoutTenantInput = {
  create?: UnitCreateWithoutTenantInput
  connect?: UnitWhereUniqueInput
  connectOrCreate?: UnitCreateOrConnectWithoutTenantInput
}

export type UnitUpdateOneWithoutTenantInput = {
  create?: UnitCreateWithoutTenantInput
  connect?: UnitWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: UnitUpdateWithoutTenantDataInput
  upsert?: UnitUpsertWithoutTenantInput
  connectOrCreate?: UnitCreateOrConnectWithoutTenantInput
}

export type UnitCreateManyWithoutAgentInput = {
  create?: Enumerable<UnitCreateWithoutAgentInput>
  connect?: Enumerable<UnitWhereUniqueInput>
  connectOrCreate?: Enumerable<UnitCreateOrConnectWithoutAgentInput>
}

export type UnitUpdateManyWithoutAgentInput = {
  create?: Enumerable<UnitCreateWithoutAgentInput>
  connect?: Enumerable<UnitWhereUniqueInput>
  set?: Enumerable<UnitWhereUniqueInput>
  disconnect?: Enumerable<UnitWhereUniqueInput>
  delete?: Enumerable<UnitWhereUniqueInput>
  update?: Enumerable<UnitUpdateWithWhereUniqueWithoutAgentInput>
  updateMany?: Enumerable<UnitUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<UnitScalarWhereInput>
  upsert?: Enumerable<UnitUpsertWithWhereUniqueWithoutAgentInput>
  connectOrCreate?: Enumerable<UnitCreateOrConnectWithoutAgentInput>
}

export type UnitCreateManyWithoutBuildingInput = {
  create?: Enumerable<UnitCreateWithoutBuildingInput>
  connect?: Enumerable<UnitWhereUniqueInput>
  connectOrCreate?: Enumerable<UnitCreateOrConnectWithoutBuildingInput>
}

export type UnitUpdateManyWithoutBuildingInput = {
  create?: Enumerable<UnitCreateWithoutBuildingInput>
  connect?: Enumerable<UnitWhereUniqueInput>
  set?: Enumerable<UnitWhereUniqueInput>
  disconnect?: Enumerable<UnitWhereUniqueInput>
  delete?: Enumerable<UnitWhereUniqueInput>
  update?: Enumerable<UnitUpdateWithWhereUniqueWithoutBuildingInput>
  updateMany?: Enumerable<UnitUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<UnitScalarWhereInput>
  upsert?: Enumerable<UnitUpsertWithWhereUniqueWithoutBuildingInput>
  connectOrCreate?: Enumerable<UnitCreateOrConnectWithoutBuildingInput>
}

export type AgentCreateManyWithoutUnitsInput = {
  create?: Enumerable<AgentCreateWithoutUnitsInput>
  connect?: Enumerable<AgentWhereUniqueInput>
  connectOrCreate?: Enumerable<AgentCreateOrConnectWithoutUnitInput>
}

export type BuildingCreateOneWithoutUnitsInput = {
  create?: BuildingCreateWithoutUnitsInput
  connect?: BuildingWhereUniqueInput
  connectOrCreate?: BuildingCreateOrConnectWithoutUnitInput
}

export type OwnerCreateManyWithoutUnitsInput = {
  create?: Enumerable<OwnerCreateWithoutUnitsInput>
  connect?: Enumerable<OwnerWhereUniqueInput>
  connectOrCreate?: Enumerable<OwnerCreateOrConnectWithoutUnitInput>
}

export type TenantCreateManyWithoutUnitInput = {
  create?: Enumerable<TenantCreateWithoutUnitInput>
  connect?: Enumerable<TenantWhereUniqueInput>
  connectOrCreate?: Enumerable<TenantCreateOrConnectWithoutUnitInput>
}

export type LeaseCreateOneWithoutUnitInput = {
  create?: LeaseCreateWithoutUnitInput
  connect?: LeaseWhereUniqueInput
  connectOrCreate?: LeaseCreateOrConnectWithoutUnitInput
}

export type OccupantCreateManyWithoutUnitInput = {
  create?: Enumerable<OccupantCreateWithoutUnitInput>
  connect?: Enumerable<OccupantWhereUniqueInput>
  connectOrCreate?: Enumerable<OccupantCreateOrConnectWithoutUnitInput>
}

export type BoolFieldUpdateOperationsInput = {
  set?: boolean
}

export type NullableBoolFieldUpdateOperationsInput = {
  set?: boolean | null
}

export type NullableFloatFieldUpdateOperationsInput = {
  set?: number | null
}

export type AgentUpdateManyWithoutUnitsInput = {
  create?: Enumerable<AgentCreateWithoutUnitsInput>
  connect?: Enumerable<AgentWhereUniqueInput>
  set?: Enumerable<AgentWhereUniqueInput>
  disconnect?: Enumerable<AgentWhereUniqueInput>
  delete?: Enumerable<AgentWhereUniqueInput>
  update?: Enumerable<AgentUpdateWithWhereUniqueWithoutUnitsInput>
  updateMany?: Enumerable<AgentUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<AgentScalarWhereInput>
  upsert?: Enumerable<AgentUpsertWithWhereUniqueWithoutUnitsInput>
  connectOrCreate?: Enumerable<AgentCreateOrConnectWithoutUnitInput>
}

export type BuildingUpdateOneRequiredWithoutUnitsInput = {
  create?: BuildingCreateWithoutUnitsInput
  connect?: BuildingWhereUniqueInput
  update?: BuildingUpdateWithoutUnitsDataInput
  upsert?: BuildingUpsertWithoutUnitsInput
  connectOrCreate?: BuildingCreateOrConnectWithoutUnitInput
}

export type OwnerUpdateManyWithoutUnitsInput = {
  create?: Enumerable<OwnerCreateWithoutUnitsInput>
  connect?: Enumerable<OwnerWhereUniqueInput>
  set?: Enumerable<OwnerWhereUniqueInput>
  disconnect?: Enumerable<OwnerWhereUniqueInput>
  delete?: Enumerable<OwnerWhereUniqueInput>
  update?: Enumerable<OwnerUpdateWithWhereUniqueWithoutUnitsInput>
  updateMany?: Enumerable<OwnerUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<OwnerScalarWhereInput>
  upsert?: Enumerable<OwnerUpsertWithWhereUniqueWithoutUnitsInput>
  connectOrCreate?: Enumerable<OwnerCreateOrConnectWithoutUnitInput>
}

export type TenantUpdateManyWithoutUnitInput = {
  create?: Enumerable<TenantCreateWithoutUnitInput>
  connect?: Enumerable<TenantWhereUniqueInput>
  set?: Enumerable<TenantWhereUniqueInput>
  disconnect?: Enumerable<TenantWhereUniqueInput>
  delete?: Enumerable<TenantWhereUniqueInput>
  update?: Enumerable<TenantUpdateWithWhereUniqueWithoutUnitInput>
  updateMany?: Enumerable<TenantUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<TenantScalarWhereInput>
  upsert?: Enumerable<TenantUpsertWithWhereUniqueWithoutUnitInput>
  connectOrCreate?: Enumerable<TenantCreateOrConnectWithoutUnitInput>
}

export type LeaseUpdateOneRequiredWithoutUnitInput = {
  create?: LeaseCreateWithoutUnitInput
  connect?: LeaseWhereUniqueInput
  update?: LeaseUpdateWithoutUnitDataInput
  upsert?: LeaseUpsertWithoutUnitInput
  connectOrCreate?: LeaseCreateOrConnectWithoutUnitInput
}

export type OccupantUpdateManyWithoutUnitInput = {
  create?: Enumerable<OccupantCreateWithoutUnitInput>
  connect?: Enumerable<OccupantWhereUniqueInput>
  set?: Enumerable<OccupantWhereUniqueInput>
  disconnect?: Enumerable<OccupantWhereUniqueInput>
  delete?: Enumerable<OccupantWhereUniqueInput>
  update?: Enumerable<OccupantUpdateWithWhereUniqueWithoutUnitInput>
  updateMany?: Enumerable<OccupantUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<OccupantScalarWhereInput>
  upsert?: Enumerable<OccupantUpsertWithWhereUniqueWithoutUnitInput>
  connectOrCreate?: Enumerable<OccupantCreateOrConnectWithoutUnitInput>
}

export type UnitCreateOneWithoutOccupantsInput = {
  create?: UnitCreateWithoutOccupantsInput
  connect?: UnitWhereUniqueInput
  connectOrCreate?: UnitCreateOrConnectWithoutOccupantInput
}

export type UnitUpdateOneRequiredWithoutOccupantsInput = {
  create?: UnitCreateWithoutOccupantsInput
  connect?: UnitWhereUniqueInput
  update?: UnitUpdateWithoutOccupantsDataInput
  upsert?: UnitUpsertWithoutOccupantsInput
  connectOrCreate?: UnitCreateOrConnectWithoutOccupantInput
}

export type UnitCreateOneWithoutLeaseInput = {
  create?: UnitCreateWithoutLeaseInput
  connect?: UnitWhereUniqueInput
  connectOrCreate?: UnitCreateOrConnectWithoutLeaseInput
}

export type NullableDateTimeFieldUpdateOperationsInput = {
  set?: Date | string | null
}

export type NullableIntFieldUpdateOperationsInput = {
  set?: number | null
}

export type UnitUpdateOneRequiredWithoutLeaseInput = {
  create?: UnitCreateWithoutLeaseInput
  connect?: UnitWhereUniqueInput
  update?: UnitUpdateWithoutLeaseDataInput
  upsert?: UnitUpsertWithoutLeaseInput
  connectOrCreate?: UnitCreateOrConnectWithoutLeaseInput
}

export type NestedIntFilter = {
  equals?: number
  in?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: NestedIntFilter | null
}

export type NestedDateTimeFilter = {
  equals?: Date | string
  in?: Enumerable<Date | string>
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
  not?: NestedDateTimeFilter | null
}

export type NestedStringFilter = {
  equals?: string
  in?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: NestedStringFilter | null
}

export type NestedStringNullableFilter = {
  equals?: string | null
  in?: Enumerable<string> | null
  lt?: string | null
  lte?: string | null
  gt?: string | null
  gte?: string | null
  contains?: string | null
  startsWith?: string | null
  endsWith?: string | null
  not?: NestedStringNullableFilter | null
}

export type NestedIntNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  lt?: number | null
  lte?: number | null
  gt?: number | null
  gte?: number | null
  not?: NestedIntNullableFilter | null
}

export type NestedBoolFilter = {
  equals?: boolean
  not?: NestedBoolFilter | null
}

export type NestedBoolNullableFilter = {
  equals?: boolean | null
  not?: NestedBoolNullableFilter | null
}

export type NestedFloatNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  lt?: number | null
  lte?: number | null
  gt?: number | null
  gte?: number | null
  not?: NestedFloatNullableFilter | null
}

export type NestedDateTimeNullableFilter = {
  equals?: Date | string | null
  in?: Enumerable<Date | string> | null
  lt?: Date | string | null
  lte?: Date | string | null
  gt?: Date | string | null
  gte?: Date | string | null
  not?: NestedDateTimeNullableFilter | null
}

export type UnitCreateWithoutOwnerInput = {
  createdAt?: Date | string
  apt: string
  sale: boolean
  pets?: boolean | null
  dogBreed?: string | null
  storageL?: boolean | null
  storageB?: boolean | null
  advertisement: string
  floorplan?: string | null
  sqft?: number | null
  purchasePrice?: number | null
  insurance?: string | null
  tenantInsurance?: string | null
  agent?: AgentCreateManyWithoutUnitsInput
  building: BuildingCreateOneWithoutUnitsInput
  tenant?: TenantCreateManyWithoutUnitInput
  lease?: LeaseCreateOneWithoutUnitInput
  occupants?: OccupantCreateManyWithoutUnitInput
}

export type UnitCreateOrConnectWithoutOwnerInput = {
  where: UnitWhereUniqueInput
  create: UnitCreateWithoutOwnerInput
}

export type UnitUpdateWithWhereUniqueWithoutOwnerInput = {
  where: UnitWhereUniqueInput
  data: UnitUpdateWithoutOwnerDataInput
}

export type UnitUpdateManyWithWhereNestedInput = {
  where: UnitScalarWhereInput
  data: UnitUpdateManyDataInput
}

export type UnitScalarWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  buildingId?: number | IntFilter
  apt?: string | StringFilter
  sale?: boolean | BooleanFilter
  agent?: AgentFilter | null
  owner?: OwnerFilter | null
  tenant?: TenantFilter | null
  pets?: boolean | NullableBooleanFilter | null
  dogBreed?: string | NullableStringFilter | null
  storageL?: boolean | NullableBooleanFilter | null
  storageB?: boolean | NullableBooleanFilter | null
  advertisement?: string | StringFilter
  occupants?: OccupantFilter | null
  floorplan?: string | NullableStringFilter | null
  sqft?: number | NullableFloatFilter | null
  purchasePrice?: number | NullableFloatFilter | null
  insurance?: string | NullableStringFilter | null
  tenantInsurance?: string | NullableStringFilter | null
  AND?: Enumerable<UnitScalarWhereInput>
  OR?: Array<UnitScalarWhereInput>
  NOT?: Enumerable<UnitScalarWhereInput>
}

export type UnitUpsertWithWhereUniqueWithoutOwnerInput = {
  where: UnitWhereUniqueInput
  update: UnitUpdateWithoutOwnerDataInput
  create: UnitCreateWithoutOwnerInput
}

export type UnitCreateWithoutTenantInput = {
  createdAt?: Date | string
  apt: string
  sale: boolean
  pets?: boolean | null
  dogBreed?: string | null
  storageL?: boolean | null
  storageB?: boolean | null
  advertisement: string
  floorplan?: string | null
  sqft?: number | null
  purchasePrice?: number | null
  insurance?: string | null
  tenantInsurance?: string | null
  agent?: AgentCreateManyWithoutUnitsInput
  building: BuildingCreateOneWithoutUnitsInput
  owner?: OwnerCreateManyWithoutUnitsInput
  lease?: LeaseCreateOneWithoutUnitInput
  occupants?: OccupantCreateManyWithoutUnitInput
}

export type UnitCreateOrConnectWithoutTenantInput = {
  where: UnitWhereUniqueInput
  create: UnitCreateWithoutTenantInput
}

export type UnitUpdateWithoutTenantDataInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  apt?: StringFieldUpdateOperationsInput
  sale?: BoolFieldUpdateOperationsInput
  pets?: NullableBoolFieldUpdateOperationsInput
  dogBreed?: NullableStringFieldUpdateOperationsInput
  storageL?: NullableBoolFieldUpdateOperationsInput
  storageB?: NullableBoolFieldUpdateOperationsInput
  advertisement?: StringFieldUpdateOperationsInput
  floorplan?: NullableStringFieldUpdateOperationsInput
  sqft?: NullableFloatFieldUpdateOperationsInput
  purchasePrice?: NullableFloatFieldUpdateOperationsInput
  insurance?: NullableStringFieldUpdateOperationsInput
  tenantInsurance?: NullableStringFieldUpdateOperationsInput
  agent?: AgentUpdateManyWithoutUnitsInput
  building?: BuildingUpdateOneRequiredWithoutUnitsInput
  owner?: OwnerUpdateManyWithoutUnitsInput
  lease?: LeaseUpdateOneRequiredWithoutUnitInput
  occupants?: OccupantUpdateManyWithoutUnitInput
}

export type UnitUpsertWithoutTenantInput = {
  update: UnitUpdateWithoutTenantDataInput
  create: UnitCreateWithoutTenantInput
}

export type UnitCreateWithoutAgentInput = {
  createdAt?: Date | string
  apt: string
  sale: boolean
  pets?: boolean | null
  dogBreed?: string | null
  storageL?: boolean | null
  storageB?: boolean | null
  advertisement: string
  floorplan?: string | null
  sqft?: number | null
  purchasePrice?: number | null
  insurance?: string | null
  tenantInsurance?: string | null
  building: BuildingCreateOneWithoutUnitsInput
  owner?: OwnerCreateManyWithoutUnitsInput
  tenant?: TenantCreateManyWithoutUnitInput
  lease?: LeaseCreateOneWithoutUnitInput
  occupants?: OccupantCreateManyWithoutUnitInput
}

export type UnitCreateOrConnectWithoutAgentInput = {
  where: UnitWhereUniqueInput
  create: UnitCreateWithoutAgentInput
}

export type UnitUpdateWithWhereUniqueWithoutAgentInput = {
  where: UnitWhereUniqueInput
  data: UnitUpdateWithoutAgentDataInput
}

export type UnitUpsertWithWhereUniqueWithoutAgentInput = {
  where: UnitWhereUniqueInput
  update: UnitUpdateWithoutAgentDataInput
  create: UnitCreateWithoutAgentInput
}

export type UnitCreateWithoutBuildingInput = {
  createdAt?: Date | string
  apt: string
  sale: boolean
  pets?: boolean | null
  dogBreed?: string | null
  storageL?: boolean | null
  storageB?: boolean | null
  advertisement: string
  floorplan?: string | null
  sqft?: number | null
  purchasePrice?: number | null
  insurance?: string | null
  tenantInsurance?: string | null
  agent?: AgentCreateManyWithoutUnitsInput
  owner?: OwnerCreateManyWithoutUnitsInput
  tenant?: TenantCreateManyWithoutUnitInput
  lease?: LeaseCreateOneWithoutUnitInput
  occupants?: OccupantCreateManyWithoutUnitInput
}

export type UnitCreateOrConnectWithoutBuildingInput = {
  where: UnitWhereUniqueInput
  create: UnitCreateWithoutBuildingInput
}

export type UnitUpdateWithWhereUniqueWithoutBuildingInput = {
  where: UnitWhereUniqueInput
  data: UnitUpdateWithoutBuildingDataInput
}

export type UnitUpsertWithWhereUniqueWithoutBuildingInput = {
  where: UnitWhereUniqueInput
  update: UnitUpdateWithoutBuildingDataInput
  create: UnitCreateWithoutBuildingInput
}

export type AgentCreateWithoutUnitsInput = {
  createdAt?: Date | string
  name: string
  email: string
  password: string
  phone: string
  altPhone: string
}

export type AgentCreateOrConnectWithoutUnitInput = {
  where: AgentWhereUniqueInput
  create: AgentCreateWithoutUnitsInput
}

export type BuildingCreateWithoutUnitsInput = {
  createdAt?: Date | string
  address: string
  name?: string | null
  phone: string
  email: string
  notes: string
  insurance: string
  boardPackages: string
  salesapplication: string
  salesPackage: string
  specialDocuments: string
}

export type BuildingCreateOrConnectWithoutUnitInput = {
  where: BuildingWhereUniqueInput
  create: BuildingCreateWithoutUnitsInput
}

export type OwnerCreateWithoutUnitsInput = {
  createdAt?: Date | string
  name: string
  address: string
  phone?: string | null
  email?: string | null
  notes?: string | null
}

export type OwnerCreateOrConnectWithoutUnitInput = {
  where: OwnerWhereUniqueInput
  create: OwnerCreateWithoutUnitsInput
}

export type TenantCreateWithoutUnitInput = {
  createdAt?: Date | string
  name: string
  address: string
  phone?: string | null
  email?: string | null
  notes?: string | null
}

export type TenantCreateOrConnectWithoutUnitInput = {
  where: TenantWhereUniqueInput
  create: TenantCreateWithoutUnitInput
}

export type LeaseCreateWithoutUnitInput = {
  createdAt?: Date | string
  term?: Date | string | null
  amount?: number | null
  extension?: string | null
  notice?: number | null
  showDate: Date | string
  security: string
  pdfLeaseSigned?: string | null
  pdfLeaseUnsigned?: string | null
  wordRider?: string | null
}

export type LeaseCreateOrConnectWithoutUnitInput = {
  where: LeaseWhereUniqueInput
  create: LeaseCreateWithoutUnitInput
}

export type OccupantCreateWithoutUnitInput = {
  createdAt?: Date | string
  name: string
  email: string
  phone: string
}

export type OccupantCreateOrConnectWithoutUnitInput = {
  where: OccupantWhereUniqueInput
  create: OccupantCreateWithoutUnitInput
}

export type AgentUpdateWithWhereUniqueWithoutUnitsInput = {
  where: AgentWhereUniqueInput
  data: AgentUpdateWithoutUnitsDataInput
}

export type AgentUpdateManyWithWhereNestedInput = {
  where: AgentScalarWhereInput
  data: AgentUpdateManyDataInput
}

export type AgentScalarWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  name?: string | StringFilter
  email?: string | StringFilter
  password?: string | StringFilter
  phone?: string | StringFilter
  altPhone?: string | StringFilter
  units?: UnitFilter | null
  AND?: Enumerable<AgentScalarWhereInput>
  OR?: Array<AgentScalarWhereInput>
  NOT?: Enumerable<AgentScalarWhereInput>
}

export type AgentUpsertWithWhereUniqueWithoutUnitsInput = {
  where: AgentWhereUniqueInput
  update: AgentUpdateWithoutUnitsDataInput
  create: AgentCreateWithoutUnitsInput
}

export type BuildingUpdateWithoutUnitsDataInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  address?: StringFieldUpdateOperationsInput
  name?: NullableStringFieldUpdateOperationsInput
  phone?: StringFieldUpdateOperationsInput
  email?: StringFieldUpdateOperationsInput
  notes?: StringFieldUpdateOperationsInput
  insurance?: StringFieldUpdateOperationsInput
  boardPackages?: StringFieldUpdateOperationsInput
  salesapplication?: StringFieldUpdateOperationsInput
  salesPackage?: StringFieldUpdateOperationsInput
  specialDocuments?: StringFieldUpdateOperationsInput
}

export type BuildingUpsertWithoutUnitsInput = {
  update: BuildingUpdateWithoutUnitsDataInput
  create: BuildingCreateWithoutUnitsInput
}

export type OwnerUpdateWithWhereUniqueWithoutUnitsInput = {
  where: OwnerWhereUniqueInput
  data: OwnerUpdateWithoutUnitsDataInput
}

export type OwnerUpdateManyWithWhereNestedInput = {
  where: OwnerScalarWhereInput
  data: OwnerUpdateManyDataInput
}

export type OwnerScalarWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  name?: string | StringFilter
  address?: string | StringFilter
  phone?: string | NullableStringFilter | null
  email?: string | NullableStringFilter | null
  units?: UnitFilter | null
  notes?: string | NullableStringFilter | null
  AND?: Enumerable<OwnerScalarWhereInput>
  OR?: Array<OwnerScalarWhereInput>
  NOT?: Enumerable<OwnerScalarWhereInput>
}

export type OwnerUpsertWithWhereUniqueWithoutUnitsInput = {
  where: OwnerWhereUniqueInput
  update: OwnerUpdateWithoutUnitsDataInput
  create: OwnerCreateWithoutUnitsInput
}

export type TenantUpdateWithWhereUniqueWithoutUnitInput = {
  where: TenantWhereUniqueInput
  data: TenantUpdateWithoutUnitDataInput
}

export type TenantUpdateManyWithWhereNestedInput = {
  where: TenantScalarWhereInput
  data: TenantUpdateManyDataInput
}

export type TenantScalarWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  name?: string | StringFilter
  address?: string | StringFilter
  phone?: string | NullableStringFilter | null
  email?: string | NullableStringFilter | null
  unitId?: number | NullableIntFilter | null
  notes?: string | NullableStringFilter | null
  AND?: Enumerable<TenantScalarWhereInput>
  OR?: Array<TenantScalarWhereInput>
  NOT?: Enumerable<TenantScalarWhereInput>
}

export type TenantUpsertWithWhereUniqueWithoutUnitInput = {
  where: TenantWhereUniqueInput
  update: TenantUpdateWithoutUnitDataInput
  create: TenantCreateWithoutUnitInput
}

export type LeaseUpdateWithoutUnitDataInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  term?: NullableDateTimeFieldUpdateOperationsInput
  amount?: NullableFloatFieldUpdateOperationsInput
  extension?: NullableStringFieldUpdateOperationsInput
  notice?: NullableIntFieldUpdateOperationsInput
  showDate?: DateTimeFieldUpdateOperationsInput
  security?: StringFieldUpdateOperationsInput
  pdfLeaseSigned?: NullableStringFieldUpdateOperationsInput
  pdfLeaseUnsigned?: NullableStringFieldUpdateOperationsInput
  wordRider?: NullableStringFieldUpdateOperationsInput
}

export type LeaseUpsertWithoutUnitInput = {
  update: LeaseUpdateWithoutUnitDataInput
  create: LeaseCreateWithoutUnitInput
}

export type OccupantUpdateWithWhereUniqueWithoutUnitInput = {
  where: OccupantWhereUniqueInput
  data: OccupantUpdateWithoutUnitDataInput
}

export type OccupantUpdateManyWithWhereNestedInput = {
  where: OccupantScalarWhereInput
  data: OccupantUpdateManyDataInput
}

export type OccupantScalarWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  name?: string | StringFilter
  email?: string | StringFilter
  phone?: string | StringFilter
  unitId?: number | IntFilter
  AND?: Enumerable<OccupantScalarWhereInput>
  OR?: Array<OccupantScalarWhereInput>
  NOT?: Enumerable<OccupantScalarWhereInput>
}

export type OccupantUpsertWithWhereUniqueWithoutUnitInput = {
  where: OccupantWhereUniqueInput
  update: OccupantUpdateWithoutUnitDataInput
  create: OccupantCreateWithoutUnitInput
}

export type UnitCreateWithoutOccupantsInput = {
  createdAt?: Date | string
  apt: string
  sale: boolean
  pets?: boolean | null
  dogBreed?: string | null
  storageL?: boolean | null
  storageB?: boolean | null
  advertisement: string
  floorplan?: string | null
  sqft?: number | null
  purchasePrice?: number | null
  insurance?: string | null
  tenantInsurance?: string | null
  agent?: AgentCreateManyWithoutUnitsInput
  building: BuildingCreateOneWithoutUnitsInput
  owner?: OwnerCreateManyWithoutUnitsInput
  tenant?: TenantCreateManyWithoutUnitInput
  lease?: LeaseCreateOneWithoutUnitInput
}

export type UnitCreateOrConnectWithoutOccupantInput = {
  where: UnitWhereUniqueInput
  create: UnitCreateWithoutOccupantsInput
}

export type UnitUpdateWithoutOccupantsDataInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  apt?: StringFieldUpdateOperationsInput
  sale?: BoolFieldUpdateOperationsInput
  pets?: NullableBoolFieldUpdateOperationsInput
  dogBreed?: NullableStringFieldUpdateOperationsInput
  storageL?: NullableBoolFieldUpdateOperationsInput
  storageB?: NullableBoolFieldUpdateOperationsInput
  advertisement?: StringFieldUpdateOperationsInput
  floorplan?: NullableStringFieldUpdateOperationsInput
  sqft?: NullableFloatFieldUpdateOperationsInput
  purchasePrice?: NullableFloatFieldUpdateOperationsInput
  insurance?: NullableStringFieldUpdateOperationsInput
  tenantInsurance?: NullableStringFieldUpdateOperationsInput
  agent?: AgentUpdateManyWithoutUnitsInput
  building?: BuildingUpdateOneRequiredWithoutUnitsInput
  owner?: OwnerUpdateManyWithoutUnitsInput
  tenant?: TenantUpdateManyWithoutUnitInput
  lease?: LeaseUpdateOneRequiredWithoutUnitInput
}

export type UnitUpsertWithoutOccupantsInput = {
  update: UnitUpdateWithoutOccupantsDataInput
  create: UnitCreateWithoutOccupantsInput
}

export type UnitCreateWithoutLeaseInput = {
  createdAt?: Date | string
  apt: string
  sale: boolean
  pets?: boolean | null
  dogBreed?: string | null
  storageL?: boolean | null
  storageB?: boolean | null
  advertisement: string
  floorplan?: string | null
  sqft?: number | null
  purchasePrice?: number | null
  insurance?: string | null
  tenantInsurance?: string | null
  agent?: AgentCreateManyWithoutUnitsInput
  building: BuildingCreateOneWithoutUnitsInput
  owner?: OwnerCreateManyWithoutUnitsInput
  tenant?: TenantCreateManyWithoutUnitInput
  occupants?: OccupantCreateManyWithoutUnitInput
}

export type UnitCreateOrConnectWithoutLeaseInput = {
  where: UnitWhereUniqueInput
  create: UnitCreateWithoutLeaseInput
}

export type UnitUpdateWithoutLeaseDataInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  apt?: StringFieldUpdateOperationsInput
  sale?: BoolFieldUpdateOperationsInput
  pets?: NullableBoolFieldUpdateOperationsInput
  dogBreed?: NullableStringFieldUpdateOperationsInput
  storageL?: NullableBoolFieldUpdateOperationsInput
  storageB?: NullableBoolFieldUpdateOperationsInput
  advertisement?: StringFieldUpdateOperationsInput
  floorplan?: NullableStringFieldUpdateOperationsInput
  sqft?: NullableFloatFieldUpdateOperationsInput
  purchasePrice?: NullableFloatFieldUpdateOperationsInput
  insurance?: NullableStringFieldUpdateOperationsInput
  tenantInsurance?: NullableStringFieldUpdateOperationsInput
  agent?: AgentUpdateManyWithoutUnitsInput
  building?: BuildingUpdateOneRequiredWithoutUnitsInput
  owner?: OwnerUpdateManyWithoutUnitsInput
  tenant?: TenantUpdateManyWithoutUnitInput
  occupants?: OccupantUpdateManyWithoutUnitInput
}

export type UnitUpsertWithoutLeaseInput = {
  update: UnitUpdateWithoutLeaseDataInput
  create: UnitCreateWithoutLeaseInput
}

export type UnitUpdateWithoutOwnerDataInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  apt?: StringFieldUpdateOperationsInput
  sale?: BoolFieldUpdateOperationsInput
  pets?: NullableBoolFieldUpdateOperationsInput
  dogBreed?: NullableStringFieldUpdateOperationsInput
  storageL?: NullableBoolFieldUpdateOperationsInput
  storageB?: NullableBoolFieldUpdateOperationsInput
  advertisement?: StringFieldUpdateOperationsInput
  floorplan?: NullableStringFieldUpdateOperationsInput
  sqft?: NullableFloatFieldUpdateOperationsInput
  purchasePrice?: NullableFloatFieldUpdateOperationsInput
  insurance?: NullableStringFieldUpdateOperationsInput
  tenantInsurance?: NullableStringFieldUpdateOperationsInput
  agent?: AgentUpdateManyWithoutUnitsInput
  building?: BuildingUpdateOneRequiredWithoutUnitsInput
  tenant?: TenantUpdateManyWithoutUnitInput
  lease?: LeaseUpdateOneRequiredWithoutUnitInput
  occupants?: OccupantUpdateManyWithoutUnitInput
}

export type UnitUpdateManyDataInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  apt?: StringFieldUpdateOperationsInput
  sale?: BoolFieldUpdateOperationsInput
  pets?: NullableBoolFieldUpdateOperationsInput
  dogBreed?: NullableStringFieldUpdateOperationsInput
  storageL?: NullableBoolFieldUpdateOperationsInput
  storageB?: NullableBoolFieldUpdateOperationsInput
  advertisement?: StringFieldUpdateOperationsInput
  floorplan?: NullableStringFieldUpdateOperationsInput
  sqft?: NullableFloatFieldUpdateOperationsInput
  purchasePrice?: NullableFloatFieldUpdateOperationsInput
  insurance?: NullableStringFieldUpdateOperationsInput
  tenantInsurance?: NullableStringFieldUpdateOperationsInput
}

export type UnitUpdateWithoutAgentDataInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  apt?: StringFieldUpdateOperationsInput
  sale?: BoolFieldUpdateOperationsInput
  pets?: NullableBoolFieldUpdateOperationsInput
  dogBreed?: NullableStringFieldUpdateOperationsInput
  storageL?: NullableBoolFieldUpdateOperationsInput
  storageB?: NullableBoolFieldUpdateOperationsInput
  advertisement?: StringFieldUpdateOperationsInput
  floorplan?: NullableStringFieldUpdateOperationsInput
  sqft?: NullableFloatFieldUpdateOperationsInput
  purchasePrice?: NullableFloatFieldUpdateOperationsInput
  insurance?: NullableStringFieldUpdateOperationsInput
  tenantInsurance?: NullableStringFieldUpdateOperationsInput
  building?: BuildingUpdateOneRequiredWithoutUnitsInput
  owner?: OwnerUpdateManyWithoutUnitsInput
  tenant?: TenantUpdateManyWithoutUnitInput
  lease?: LeaseUpdateOneRequiredWithoutUnitInput
  occupants?: OccupantUpdateManyWithoutUnitInput
}

export type UnitUpdateWithoutBuildingDataInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  apt?: StringFieldUpdateOperationsInput
  sale?: BoolFieldUpdateOperationsInput
  pets?: NullableBoolFieldUpdateOperationsInput
  dogBreed?: NullableStringFieldUpdateOperationsInput
  storageL?: NullableBoolFieldUpdateOperationsInput
  storageB?: NullableBoolFieldUpdateOperationsInput
  advertisement?: StringFieldUpdateOperationsInput
  floorplan?: NullableStringFieldUpdateOperationsInput
  sqft?: NullableFloatFieldUpdateOperationsInput
  purchasePrice?: NullableFloatFieldUpdateOperationsInput
  insurance?: NullableStringFieldUpdateOperationsInput
  tenantInsurance?: NullableStringFieldUpdateOperationsInput
  agent?: AgentUpdateManyWithoutUnitsInput
  owner?: OwnerUpdateManyWithoutUnitsInput
  tenant?: TenantUpdateManyWithoutUnitInput
  lease?: LeaseUpdateOneRequiredWithoutUnitInput
  occupants?: OccupantUpdateManyWithoutUnitInput
}

export type AgentUpdateWithoutUnitsDataInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  name?: StringFieldUpdateOperationsInput
  email?: StringFieldUpdateOperationsInput
  password?: StringFieldUpdateOperationsInput
  phone?: StringFieldUpdateOperationsInput
  altPhone?: StringFieldUpdateOperationsInput
}

export type AgentUpdateManyDataInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  name?: StringFieldUpdateOperationsInput
  email?: StringFieldUpdateOperationsInput
  password?: StringFieldUpdateOperationsInput
  phone?: StringFieldUpdateOperationsInput
  altPhone?: StringFieldUpdateOperationsInput
}

export type OwnerUpdateWithoutUnitsDataInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  name?: StringFieldUpdateOperationsInput
  address?: StringFieldUpdateOperationsInput
  phone?: NullableStringFieldUpdateOperationsInput
  email?: NullableStringFieldUpdateOperationsInput
  notes?: NullableStringFieldUpdateOperationsInput
}

export type OwnerUpdateManyDataInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  name?: StringFieldUpdateOperationsInput
  address?: StringFieldUpdateOperationsInput
  phone?: NullableStringFieldUpdateOperationsInput
  email?: NullableStringFieldUpdateOperationsInput
  notes?: NullableStringFieldUpdateOperationsInput
}

export type TenantUpdateWithoutUnitDataInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  name?: StringFieldUpdateOperationsInput
  address?: StringFieldUpdateOperationsInput
  phone?: NullableStringFieldUpdateOperationsInput
  email?: NullableStringFieldUpdateOperationsInput
  notes?: NullableStringFieldUpdateOperationsInput
}

export type TenantUpdateManyDataInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  name?: StringFieldUpdateOperationsInput
  address?: StringFieldUpdateOperationsInput
  phone?: NullableStringFieldUpdateOperationsInput
  email?: NullableStringFieldUpdateOperationsInput
  notes?: NullableStringFieldUpdateOperationsInput
}

export type OccupantUpdateWithoutUnitDataInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  name?: StringFieldUpdateOperationsInput
  email?: StringFieldUpdateOperationsInput
  phone?: StringFieldUpdateOperationsInput
}

export type OccupantUpdateManyDataInput = {
  createdAt?: DateTimeFieldUpdateOperationsInput
  name?: StringFieldUpdateOperationsInput
  email?: StringFieldUpdateOperationsInput
  phone?: StringFieldUpdateOperationsInput
}

export type NullableStringFilter = {
  equals?: string | null
  not?: string | null | NullableStringFilter
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string | null
  lte?: string | null
  gt?: string | null
  gte?: string | null
  contains?: string | null
  startsWith?: string | null
  endsWith?: string | null
}

export type UnitFilter = {
  every?: UnitWhereInput
  some?: UnitWhereInput
  none?: UnitWhereInput
}

export type NullableIntFilter = {
  equals?: number | null
  not?: number | null | NullableIntFilter
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number | null
  lte?: number | null
  gt?: number | null
  gte?: number | null
}

export type BooleanFilter = {
  equals?: boolean
  not?: boolean | BooleanFilter
}

export type AgentFilter = {
  every?: AgentWhereInput
  some?: AgentWhereInput
  none?: AgentWhereInput
}

export type OwnerFilter = {
  every?: OwnerWhereInput
  some?: OwnerWhereInput
  none?: OwnerWhereInput
}

export type TenantFilter = {
  every?: TenantWhereInput
  some?: TenantWhereInput
  none?: TenantWhereInput
}

export type NullableBooleanFilter = {
  equals?: boolean | null
  not?: boolean | null | NullableBooleanFilter
}

export type OccupantFilter = {
  every?: OccupantWhereInput
  some?: OccupantWhereInput
  none?: OccupantWhereInput
}

export type NullableFloatFilter = {
  equals?: number | null
  not?: number | null | NullableFloatFilter
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number | null
  lte?: number | null
  gt?: number | null
  gte?: number | null
}

export type NullableDateTimeFilter = {
  equals?: Date | string | null
  not?: Date | string | null | NullableDateTimeFilter
  in?: Enumerable<Date | string> | null
  notIn?: Enumerable<Date | string> | null
  lt?: Date | string | null
  lte?: Date | string | null
  gt?: Date | string | null
  gte?: Date | string | null
}

/**
 * Batch Payload for updateMany & deleteMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
