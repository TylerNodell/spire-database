import {
  DMMF,
  DMMFClass,
  Engine,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  sqltag as sql,
  empty,
  join,
  raw,
} from '@prisma/client/runtime';

export { PrismaClientKnownRequestError }
export { PrismaClientUnknownRequestError }
export { PrismaClientRustPanicError }
export { PrismaClientInitializationError }
export { PrismaClientValidationError }

/**
 * Re-export of sql-template-tag
 */
export { sql, empty, join, raw }

/**
 * Prisma Client JS version: 2.4.1
 * Query Engine version: 195d4bdc2d16132977f4ba7a8ca312f7906cb086
 */
export declare type PrismaVersion = {
  client: string
}

export declare const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export declare type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export declare interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export declare type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export declare type InputJsonObject = {[Key in string]?: JsonValue}
 
export declare interface InputJsonArray extends Array<JsonValue> {}
 
export declare type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray

declare type SelectAndInclude = {
  select: any
  include: any
}

declare type HasSelect = {
  select: any
}

declare type HasInclude = {
  include: any
}

declare type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export declare type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export declare type Enumerable<T> = T | Array<T>;

export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

export declare type TruthyKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

export declare type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}


/**
 * Client
**/

export declare type Datasource = {
  url?: string
}

export type Datasources = {
  db?: Datasource
}

export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your prisma.schema file
   */
  datasources?: Datasources

  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat

  /**
   * @example
   * ```
   * // Defaults to stdout
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events
   * log: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * ]
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: Array<LogLevel | LogDefinition>
}

export type Hooks = {
  beforeRequest?: (options: {query: string, path: string[], rootField?: string, typeName?: string, document: any}) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends Array<LogLevel | LogDefinition>> = GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]> 

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type Action =
  | 'findOne'
  | 'findMany'
  | 'create'
  | 'update'
  | 'updateMany'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'

/**
 * These options are being passed in to the middleware as "params"
 */
export type MiddlewareParams = {
  model?: string
  action: Action
  args: any
  dataPath: string[]
  runInTransaction: boolean
}

/**
 * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
 */
export type Middleware<T = any> = (
  params: MiddlewareParams,
  next: (params: MiddlewareParams) => Promise<T>,
) => Promise<T>

// tested in getLogLevel.test.ts
export declare function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Owners
 * const owners = await prisma.owner.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md).
 */
export declare class PrismaClient<
  T extends PrismaClientOptions = PrismaClientOptions,
  U = keyof T extends 'log' ? T['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<T['log']> : never : never
> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;
  /**
   * @private
   */
  private engine: Engine;
  /**
   * @private
   */
  private errorFormat: ErrorFormat;

  /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Owners
   * const owners = await prisma.owner.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md).
   */
  constructor(optionsArg?: T);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * @deprecated renamed to `$on`
   */
  on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * Connect with the database
   */
  $connect(): Promise<void>;
  /**
   * @deprecated renamed to `$connect`
   */
  connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;
  /**
   * @deprecated renamed to `$disconnect`
   */
  disconnect(): Promise<any>;

  

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md#raw-database-access).
  */
  $executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * @deprecated renamed to `$executeRaw`
   */
  executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://github.com/prisma/prisma/blob/master/docs/prisma-client-js/api.md#raw-database-access).
  */
  $queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;
 
  /**
   * @deprecated renamed to `$executeRaw`
   */
  queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;

  /**
   * `prisma.owner`: Exposes CRUD operations for the **Owner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Owners
    * const owners = await prisma.owner.findMany()
    * ```
    */
  get owner(): OwnerDelegate;

  /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): TenantDelegate;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): AgentDelegate;

  /**
   * `prisma.building`: Exposes CRUD operations for the **Building** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Buildings
    * const buildings = await prisma.building.findMany()
    * ```
    */
  get building(): BuildingDelegate;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): UnitDelegate;
}



/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export declare const SortOrder: {
  asc: 'asc',
  desc: 'desc'
};

export declare type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]



/**
 * Model Owner
 */

export type Owner = {
  id: number
  createdAt: Date
  name: string
  phone: string | null
  email: string | null
}



export type OwnerSelect = {
  id?: boolean
  createdAt?: boolean
  name?: boolean
  phone?: boolean
  email?: boolean
  units?: boolean | FindManyUnitArgs
}

export type OwnerInclude = {
  units?: boolean | FindManyUnitArgs
}

export type OwnerGetPayload<
  S extends boolean | null | undefined | OwnerArgs,
  U = keyof S
> = S extends true
  ? Owner
  : S extends undefined
  ? never
  : S extends OwnerArgs | FindManyOwnerArgs
  ? 'include' extends U
    ? Owner  & {
      [P in TrueKeys<S['include']>]:
      P extends 'units'
      ? Array<UnitGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Owner ? Owner[P]
: 
      P extends 'units'
      ? Array<UnitGetPayload<S['select'][P]>> : never
    }
  : Owner
: Owner


export interface OwnerDelegate {
  /**
   * Find zero or one Owner.
   * @param {FindOneOwnerArgs} args - Arguments to find a Owner
   * @example
   * // Get one Owner
   * const owner = await prisma.owner.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneOwnerArgs>(
    args: Subset<T, FindOneOwnerArgs>
  ): CheckSelect<T, Prisma__OwnerClient<Owner | null>, Prisma__OwnerClient<OwnerGetPayload<T> | null>>
  /**
   * Find zero or more Owners.
   * @param {FindManyOwnerArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Owners
   * const owners = await prisma.owner.findMany()
   * 
   * // Get first 10 Owners
   * const owners = await prisma.owner.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const ownerWithIdOnly = await prisma.owner.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyOwnerArgs>(
    args?: Subset<T, FindManyOwnerArgs>
  ): CheckSelect<T, Promise<Array<Owner>>, Promise<Array<OwnerGetPayload<T>>>>
  /**
   * Create a Owner.
   * @param {OwnerCreateArgs} args - Arguments to create a Owner.
   * @example
   * // Create one Owner
   * const Owner = await prisma.owner.create({
   *   data: {
   *     // ... data to create a Owner
   *   }
   * })
   * 
  **/
  create<T extends OwnerCreateArgs>(
    args: Subset<T, OwnerCreateArgs>
  ): CheckSelect<T, Prisma__OwnerClient<Owner>, Prisma__OwnerClient<OwnerGetPayload<T>>>
  /**
   * Delete a Owner.
   * @param {OwnerDeleteArgs} args - Arguments to delete one Owner.
   * @example
   * // Delete one Owner
   * const Owner = await prisma.owner.delete({
   *   where: {
   *     // ... filter to delete one Owner
   *   }
   * })
   * 
  **/
  delete<T extends OwnerDeleteArgs>(
    args: Subset<T, OwnerDeleteArgs>
  ): CheckSelect<T, Prisma__OwnerClient<Owner>, Prisma__OwnerClient<OwnerGetPayload<T>>>
  /**
   * Update one Owner.
   * @param {OwnerUpdateArgs} args - Arguments to update one Owner.
   * @example
   * // Update one Owner
   * const owner = await prisma.owner.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends OwnerUpdateArgs>(
    args: Subset<T, OwnerUpdateArgs>
  ): CheckSelect<T, Prisma__OwnerClient<Owner>, Prisma__OwnerClient<OwnerGetPayload<T>>>
  /**
   * Delete zero or more Owners.
   * @param {OwnerDeleteManyArgs} args - Arguments to filter Owners to delete.
   * @example
   * // Delete a few Owners
   * const { count } = await prisma.owner.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends OwnerDeleteManyArgs>(
    args: Subset<T, OwnerDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Owners.
   * @param {OwnerUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Owners
   * const owner = await prisma.owner.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends OwnerUpdateManyArgs>(
    args: Subset<T, OwnerUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Owner.
   * @param {OwnerUpsertArgs} args - Arguments to update or create a Owner.
   * @example
   * // Update or create a Owner
   * const owner = await prisma.owner.upsert({
   *   create: {
   *     // ... data to create a Owner
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Owner we want to update
   *   }
   * })
  **/
  upsert<T extends OwnerUpsertArgs>(
    args: Subset<T, OwnerUpsertArgs>
  ): CheckSelect<T, Prisma__OwnerClient<Owner>, Prisma__OwnerClient<OwnerGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyOwnerArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Owner.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__OwnerClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  units<T extends FindManyUnitArgs = {}>(args?: Subset<T, FindManyUnitArgs>): CheckSelect<T, Promise<Array<Unit>>, Promise<Array<UnitGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Owner findOne
 */
export type FindOneOwnerArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
  /**
   * Filter, which Owner to fetch.
  **/
  where: OwnerWhereUniqueInput
}


/**
 * Owner findMany
 */
export type FindManyOwnerArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
  /**
   * Filter, which Owners to fetch.
  **/
  where?: OwnerWhereInput
  /**
   * Determine the order of the Owners to fetch.
  **/
  orderBy?: Enumerable<OwnerOrderByInput>
  /**
   * Sets the position for listing Owners.
  **/
  cursor?: OwnerWhereUniqueInput
  /**
   * The number of Owners to fetch. If negative number, it will take Owners before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Owners.
  **/
  skip?: number
}


/**
 * Owner create
 */
export type OwnerCreateArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
  /**
   * The data needed to create a Owner.
  **/
  data: OwnerCreateInput
}


/**
 * Owner update
 */
export type OwnerUpdateArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
  /**
   * The data needed to update a Owner.
  **/
  data: OwnerUpdateInput
  /**
   * Choose, which Owner to update.
  **/
  where: OwnerWhereUniqueInput
}


/**
 * Owner updateMany
 */
export type OwnerUpdateManyArgs = {
  data: OwnerUpdateManyMutationInput
  where?: OwnerWhereInput
}


/**
 * Owner upsert
 */
export type OwnerUpsertArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
  /**
   * The filter to search for the Owner to update in case it exists.
  **/
  where: OwnerWhereUniqueInput
  /**
   * In case the Owner found by the `where` argument doesn't exist, create a new Owner with this data.
  **/
  create: OwnerCreateInput
  /**
   * In case the Owner was found with the provided `where` argument, update it with this data.
  **/
  update: OwnerUpdateInput
}


/**
 * Owner delete
 */
export type OwnerDeleteArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
  /**
   * Filter which Owner to delete.
  **/
  where: OwnerWhereUniqueInput
}


/**
 * Owner deleteMany
 */
export type OwnerDeleteManyArgs = {
  where?: OwnerWhereInput
}


/**
 * Owner without action
 */
export type OwnerArgs = {
  /**
   * Select specific fields to fetch from the Owner
  **/
  select?: OwnerSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: OwnerInclude | null
}



/**
 * Model Tenant
 */

export type Tenant = {
  id: number
  createdAt: Date
  name: string
  phone: string | null
  email: string | null
  unitId: number | null
}



export type TenantSelect = {
  id?: boolean
  createdAt?: boolean
  name?: boolean
  phone?: boolean
  email?: boolean
  unit?: boolean | UnitArgs
  unitId?: boolean
}

export type TenantInclude = {
  unit?: boolean | UnitArgs
}

export type TenantGetPayload<
  S extends boolean | null | undefined | TenantArgs,
  U = keyof S
> = S extends true
  ? Tenant
  : S extends undefined
  ? never
  : S extends TenantArgs | FindManyTenantArgs
  ? 'include' extends U
    ? Tenant  & {
      [P in TrueKeys<S['include']>]:
      P extends 'unit'
      ? UnitGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Tenant ? Tenant[P]
: 
      P extends 'unit'
      ? UnitGetPayload<S['select'][P]> | null : never
    }
  : Tenant
: Tenant


export interface TenantDelegate {
  /**
   * Find zero or one Tenant.
   * @param {FindOneTenantArgs} args - Arguments to find a Tenant
   * @example
   * // Get one Tenant
   * const tenant = await prisma.tenant.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneTenantArgs>(
    args: Subset<T, FindOneTenantArgs>
  ): CheckSelect<T, Prisma__TenantClient<Tenant | null>, Prisma__TenantClient<TenantGetPayload<T> | null>>
  /**
   * Find zero or more Tenants.
   * @param {FindManyTenantArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Tenants
   * const tenants = await prisma.tenant.findMany()
   * 
   * // Get first 10 Tenants
   * const tenants = await prisma.tenant.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyTenantArgs>(
    args?: Subset<T, FindManyTenantArgs>
  ): CheckSelect<T, Promise<Array<Tenant>>, Promise<Array<TenantGetPayload<T>>>>
  /**
   * Create a Tenant.
   * @param {TenantCreateArgs} args - Arguments to create a Tenant.
   * @example
   * // Create one Tenant
   * const Tenant = await prisma.tenant.create({
   *   data: {
   *     // ... data to create a Tenant
   *   }
   * })
   * 
  **/
  create<T extends TenantCreateArgs>(
    args: Subset<T, TenantCreateArgs>
  ): CheckSelect<T, Prisma__TenantClient<Tenant>, Prisma__TenantClient<TenantGetPayload<T>>>
  /**
   * Delete a Tenant.
   * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
   * @example
   * // Delete one Tenant
   * const Tenant = await prisma.tenant.delete({
   *   where: {
   *     // ... filter to delete one Tenant
   *   }
   * })
   * 
  **/
  delete<T extends TenantDeleteArgs>(
    args: Subset<T, TenantDeleteArgs>
  ): CheckSelect<T, Prisma__TenantClient<Tenant>, Prisma__TenantClient<TenantGetPayload<T>>>
  /**
   * Update one Tenant.
   * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
   * @example
   * // Update one Tenant
   * const tenant = await prisma.tenant.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends TenantUpdateArgs>(
    args: Subset<T, TenantUpdateArgs>
  ): CheckSelect<T, Prisma__TenantClient<Tenant>, Prisma__TenantClient<TenantGetPayload<T>>>
  /**
   * Delete zero or more Tenants.
   * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
   * @example
   * // Delete a few Tenants
   * const { count } = await prisma.tenant.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends TenantDeleteManyArgs>(
    args: Subset<T, TenantDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Tenants.
   * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Tenants
   * const tenant = await prisma.tenant.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends TenantUpdateManyArgs>(
    args: Subset<T, TenantUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Tenant.
   * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
   * @example
   * // Update or create a Tenant
   * const tenant = await prisma.tenant.upsert({
   *   create: {
   *     // ... data to create a Tenant
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Tenant we want to update
   *   }
   * })
  **/
  upsert<T extends TenantUpsertArgs>(
    args: Subset<T, TenantUpsertArgs>
  ): CheckSelect<T, Prisma__TenantClient<Tenant>, Prisma__TenantClient<TenantGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyTenantArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Tenant.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__TenantClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  unit<T extends UnitArgs = {}>(args?: Subset<T, UnitArgs>): CheckSelect<T, Prisma__UnitClient<Unit | null>, Prisma__UnitClient<UnitGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Tenant findOne
 */
export type FindOneTenantArgs = {
  /**
   * Select specific fields to fetch from the Tenant
  **/
  select?: TenantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TenantInclude | null
  /**
   * Filter, which Tenant to fetch.
  **/
  where: TenantWhereUniqueInput
}


/**
 * Tenant findMany
 */
export type FindManyTenantArgs = {
  /**
   * Select specific fields to fetch from the Tenant
  **/
  select?: TenantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TenantInclude | null
  /**
   * Filter, which Tenants to fetch.
  **/
  where?: TenantWhereInput
  /**
   * Determine the order of the Tenants to fetch.
  **/
  orderBy?: Enumerable<TenantOrderByInput>
  /**
   * Sets the position for listing Tenants.
  **/
  cursor?: TenantWhereUniqueInput
  /**
   * The number of Tenants to fetch. If negative number, it will take Tenants before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Tenants.
  **/
  skip?: number
}


/**
 * Tenant create
 */
export type TenantCreateArgs = {
  /**
   * Select specific fields to fetch from the Tenant
  **/
  select?: TenantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TenantInclude | null
  /**
   * The data needed to create a Tenant.
  **/
  data: TenantCreateInput
}


/**
 * Tenant update
 */
export type TenantUpdateArgs = {
  /**
   * Select specific fields to fetch from the Tenant
  **/
  select?: TenantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TenantInclude | null
  /**
   * The data needed to update a Tenant.
  **/
  data: TenantUpdateInput
  /**
   * Choose, which Tenant to update.
  **/
  where: TenantWhereUniqueInput
}


/**
 * Tenant updateMany
 */
export type TenantUpdateManyArgs = {
  data: TenantUpdateManyMutationInput
  where?: TenantWhereInput
}


/**
 * Tenant upsert
 */
export type TenantUpsertArgs = {
  /**
   * Select specific fields to fetch from the Tenant
  **/
  select?: TenantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TenantInclude | null
  /**
   * The filter to search for the Tenant to update in case it exists.
  **/
  where: TenantWhereUniqueInput
  /**
   * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
  **/
  create: TenantCreateInput
  /**
   * In case the Tenant was found with the provided `where` argument, update it with this data.
  **/
  update: TenantUpdateInput
}


/**
 * Tenant delete
 */
export type TenantDeleteArgs = {
  /**
   * Select specific fields to fetch from the Tenant
  **/
  select?: TenantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TenantInclude | null
  /**
   * Filter which Tenant to delete.
  **/
  where: TenantWhereUniqueInput
}


/**
 * Tenant deleteMany
 */
export type TenantDeleteManyArgs = {
  where?: TenantWhereInput
}


/**
 * Tenant without action
 */
export type TenantArgs = {
  /**
   * Select specific fields to fetch from the Tenant
  **/
  select?: TenantSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: TenantInclude | null
}



/**
 * Model Agent
 */

export type Agent = {
  id: number
  createdAt: Date
  name: string
  email: string
  password: string
  phone: string
}



export type AgentSelect = {
  id?: boolean
  createdAt?: boolean
  name?: boolean
  email?: boolean
  password?: boolean
  phone?: boolean
  units?: boolean | FindManyUnitArgs
}

export type AgentInclude = {
  units?: boolean | FindManyUnitArgs
}

export type AgentGetPayload<
  S extends boolean | null | undefined | AgentArgs,
  U = keyof S
> = S extends true
  ? Agent
  : S extends undefined
  ? never
  : S extends AgentArgs | FindManyAgentArgs
  ? 'include' extends U
    ? Agent  & {
      [P in TrueKeys<S['include']>]:
      P extends 'units'
      ? Array<UnitGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Agent ? Agent[P]
: 
      P extends 'units'
      ? Array<UnitGetPayload<S['select'][P]>> : never
    }
  : Agent
: Agent


export interface AgentDelegate {
  /**
   * Find zero or one Agent.
   * @param {FindOneAgentArgs} args - Arguments to find a Agent
   * @example
   * // Get one Agent
   * const agent = await prisma.agent.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneAgentArgs>(
    args: Subset<T, FindOneAgentArgs>
  ): CheckSelect<T, Prisma__AgentClient<Agent | null>, Prisma__AgentClient<AgentGetPayload<T> | null>>
  /**
   * Find zero or more Agents.
   * @param {FindManyAgentArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Agents
   * const agents = await prisma.agent.findMany()
   * 
   * // Get first 10 Agents
   * const agents = await prisma.agent.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyAgentArgs>(
    args?: Subset<T, FindManyAgentArgs>
  ): CheckSelect<T, Promise<Array<Agent>>, Promise<Array<AgentGetPayload<T>>>>
  /**
   * Create a Agent.
   * @param {AgentCreateArgs} args - Arguments to create a Agent.
   * @example
   * // Create one Agent
   * const Agent = await prisma.agent.create({
   *   data: {
   *     // ... data to create a Agent
   *   }
   * })
   * 
  **/
  create<T extends AgentCreateArgs>(
    args: Subset<T, AgentCreateArgs>
  ): CheckSelect<T, Prisma__AgentClient<Agent>, Prisma__AgentClient<AgentGetPayload<T>>>
  /**
   * Delete a Agent.
   * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
   * @example
   * // Delete one Agent
   * const Agent = await prisma.agent.delete({
   *   where: {
   *     // ... filter to delete one Agent
   *   }
   * })
   * 
  **/
  delete<T extends AgentDeleteArgs>(
    args: Subset<T, AgentDeleteArgs>
  ): CheckSelect<T, Prisma__AgentClient<Agent>, Prisma__AgentClient<AgentGetPayload<T>>>
  /**
   * Update one Agent.
   * @param {AgentUpdateArgs} args - Arguments to update one Agent.
   * @example
   * // Update one Agent
   * const agent = await prisma.agent.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends AgentUpdateArgs>(
    args: Subset<T, AgentUpdateArgs>
  ): CheckSelect<T, Prisma__AgentClient<Agent>, Prisma__AgentClient<AgentGetPayload<T>>>
  /**
   * Delete zero or more Agents.
   * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
   * @example
   * // Delete a few Agents
   * const { count } = await prisma.agent.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends AgentDeleteManyArgs>(
    args: Subset<T, AgentDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Agents.
   * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Agents
   * const agent = await prisma.agent.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends AgentUpdateManyArgs>(
    args: Subset<T, AgentUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Agent.
   * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
   * @example
   * // Update or create a Agent
   * const agent = await prisma.agent.upsert({
   *   create: {
   *     // ... data to create a Agent
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Agent we want to update
   *   }
   * })
  **/
  upsert<T extends AgentUpsertArgs>(
    args: Subset<T, AgentUpsertArgs>
  ): CheckSelect<T, Prisma__AgentClient<Agent>, Prisma__AgentClient<AgentGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyAgentArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Agent.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__AgentClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  units<T extends FindManyUnitArgs = {}>(args?: Subset<T, FindManyUnitArgs>): CheckSelect<T, Promise<Array<Unit>>, Promise<Array<UnitGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Agent findOne
 */
export type FindOneAgentArgs = {
  /**
   * Select specific fields to fetch from the Agent
  **/
  select?: AgentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AgentInclude | null
  /**
   * Filter, which Agent to fetch.
  **/
  where: AgentWhereUniqueInput
}


/**
 * Agent findMany
 */
export type FindManyAgentArgs = {
  /**
   * Select specific fields to fetch from the Agent
  **/
  select?: AgentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AgentInclude | null
  /**
   * Filter, which Agents to fetch.
  **/
  where?: AgentWhereInput
  /**
   * Determine the order of the Agents to fetch.
  **/
  orderBy?: Enumerable<AgentOrderByInput>
  /**
   * Sets the position for listing Agents.
  **/
  cursor?: AgentWhereUniqueInput
  /**
   * The number of Agents to fetch. If negative number, it will take Agents before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Agents.
  **/
  skip?: number
}


/**
 * Agent create
 */
export type AgentCreateArgs = {
  /**
   * Select specific fields to fetch from the Agent
  **/
  select?: AgentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AgentInclude | null
  /**
   * The data needed to create a Agent.
  **/
  data: AgentCreateInput
}


/**
 * Agent update
 */
export type AgentUpdateArgs = {
  /**
   * Select specific fields to fetch from the Agent
  **/
  select?: AgentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AgentInclude | null
  /**
   * The data needed to update a Agent.
  **/
  data: AgentUpdateInput
  /**
   * Choose, which Agent to update.
  **/
  where: AgentWhereUniqueInput
}


/**
 * Agent updateMany
 */
export type AgentUpdateManyArgs = {
  data: AgentUpdateManyMutationInput
  where?: AgentWhereInput
}


/**
 * Agent upsert
 */
export type AgentUpsertArgs = {
  /**
   * Select specific fields to fetch from the Agent
  **/
  select?: AgentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AgentInclude | null
  /**
   * The filter to search for the Agent to update in case it exists.
  **/
  where: AgentWhereUniqueInput
  /**
   * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
  **/
  create: AgentCreateInput
  /**
   * In case the Agent was found with the provided `where` argument, update it with this data.
  **/
  update: AgentUpdateInput
}


/**
 * Agent delete
 */
export type AgentDeleteArgs = {
  /**
   * Select specific fields to fetch from the Agent
  **/
  select?: AgentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AgentInclude | null
  /**
   * Filter which Agent to delete.
  **/
  where: AgentWhereUniqueInput
}


/**
 * Agent deleteMany
 */
export type AgentDeleteManyArgs = {
  where?: AgentWhereInput
}


/**
 * Agent without action
 */
export type AgentArgs = {
  /**
   * Select specific fields to fetch from the Agent
  **/
  select?: AgentSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: AgentInclude | null
}



/**
 * Model Building
 */

export type Building = {
  id: number
  createdAt: Date
  address: string
  name: string | null
}



export type BuildingSelect = {
  id?: boolean
  createdAt?: boolean
  address?: boolean
  name?: boolean
  units?: boolean | FindManyUnitArgs
}

export type BuildingInclude = {
  units?: boolean | FindManyUnitArgs
}

export type BuildingGetPayload<
  S extends boolean | null | undefined | BuildingArgs,
  U = keyof S
> = S extends true
  ? Building
  : S extends undefined
  ? never
  : S extends BuildingArgs | FindManyBuildingArgs
  ? 'include' extends U
    ? Building  & {
      [P in TrueKeys<S['include']>]:
      P extends 'units'
      ? Array<UnitGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Building ? Building[P]
: 
      P extends 'units'
      ? Array<UnitGetPayload<S['select'][P]>> : never
    }
  : Building
: Building


export interface BuildingDelegate {
  /**
   * Find zero or one Building.
   * @param {FindOneBuildingArgs} args - Arguments to find a Building
   * @example
   * // Get one Building
   * const building = await prisma.building.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneBuildingArgs>(
    args: Subset<T, FindOneBuildingArgs>
  ): CheckSelect<T, Prisma__BuildingClient<Building | null>, Prisma__BuildingClient<BuildingGetPayload<T> | null>>
  /**
   * Find zero or more Buildings.
   * @param {FindManyBuildingArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Buildings
   * const buildings = await prisma.building.findMany()
   * 
   * // Get first 10 Buildings
   * const buildings = await prisma.building.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const buildingWithIdOnly = await prisma.building.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyBuildingArgs>(
    args?: Subset<T, FindManyBuildingArgs>
  ): CheckSelect<T, Promise<Array<Building>>, Promise<Array<BuildingGetPayload<T>>>>
  /**
   * Create a Building.
   * @param {BuildingCreateArgs} args - Arguments to create a Building.
   * @example
   * // Create one Building
   * const Building = await prisma.building.create({
   *   data: {
   *     // ... data to create a Building
   *   }
   * })
   * 
  **/
  create<T extends BuildingCreateArgs>(
    args: Subset<T, BuildingCreateArgs>
  ): CheckSelect<T, Prisma__BuildingClient<Building>, Prisma__BuildingClient<BuildingGetPayload<T>>>
  /**
   * Delete a Building.
   * @param {BuildingDeleteArgs} args - Arguments to delete one Building.
   * @example
   * // Delete one Building
   * const Building = await prisma.building.delete({
   *   where: {
   *     // ... filter to delete one Building
   *   }
   * })
   * 
  **/
  delete<T extends BuildingDeleteArgs>(
    args: Subset<T, BuildingDeleteArgs>
  ): CheckSelect<T, Prisma__BuildingClient<Building>, Prisma__BuildingClient<BuildingGetPayload<T>>>
  /**
   * Update one Building.
   * @param {BuildingUpdateArgs} args - Arguments to update one Building.
   * @example
   * // Update one Building
   * const building = await prisma.building.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends BuildingUpdateArgs>(
    args: Subset<T, BuildingUpdateArgs>
  ): CheckSelect<T, Prisma__BuildingClient<Building>, Prisma__BuildingClient<BuildingGetPayload<T>>>
  /**
   * Delete zero or more Buildings.
   * @param {BuildingDeleteManyArgs} args - Arguments to filter Buildings to delete.
   * @example
   * // Delete a few Buildings
   * const { count } = await prisma.building.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends BuildingDeleteManyArgs>(
    args: Subset<T, BuildingDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Buildings.
   * @param {BuildingUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Buildings
   * const building = await prisma.building.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends BuildingUpdateManyArgs>(
    args: Subset<T, BuildingUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Building.
   * @param {BuildingUpsertArgs} args - Arguments to update or create a Building.
   * @example
   * // Update or create a Building
   * const building = await prisma.building.upsert({
   *   create: {
   *     // ... data to create a Building
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Building we want to update
   *   }
   * })
  **/
  upsert<T extends BuildingUpsertArgs>(
    args: Subset<T, BuildingUpsertArgs>
  ): CheckSelect<T, Prisma__BuildingClient<Building>, Prisma__BuildingClient<BuildingGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyBuildingArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Building.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__BuildingClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  units<T extends FindManyUnitArgs = {}>(args?: Subset<T, FindManyUnitArgs>): CheckSelect<T, Promise<Array<Unit>>, Promise<Array<UnitGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Building findOne
 */
export type FindOneBuildingArgs = {
  /**
   * Select specific fields to fetch from the Building
  **/
  select?: BuildingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BuildingInclude | null
  /**
   * Filter, which Building to fetch.
  **/
  where: BuildingWhereUniqueInput
}


/**
 * Building findMany
 */
export type FindManyBuildingArgs = {
  /**
   * Select specific fields to fetch from the Building
  **/
  select?: BuildingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BuildingInclude | null
  /**
   * Filter, which Buildings to fetch.
  **/
  where?: BuildingWhereInput
  /**
   * Determine the order of the Buildings to fetch.
  **/
  orderBy?: Enumerable<BuildingOrderByInput>
  /**
   * Sets the position for listing Buildings.
  **/
  cursor?: BuildingWhereUniqueInput
  /**
   * The number of Buildings to fetch. If negative number, it will take Buildings before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Buildings.
  **/
  skip?: number
}


/**
 * Building create
 */
export type BuildingCreateArgs = {
  /**
   * Select specific fields to fetch from the Building
  **/
  select?: BuildingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BuildingInclude | null
  /**
   * The data needed to create a Building.
  **/
  data: BuildingCreateInput
}


/**
 * Building update
 */
export type BuildingUpdateArgs = {
  /**
   * Select specific fields to fetch from the Building
  **/
  select?: BuildingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BuildingInclude | null
  /**
   * The data needed to update a Building.
  **/
  data: BuildingUpdateInput
  /**
   * Choose, which Building to update.
  **/
  where: BuildingWhereUniqueInput
}


/**
 * Building updateMany
 */
export type BuildingUpdateManyArgs = {
  data: BuildingUpdateManyMutationInput
  where?: BuildingWhereInput
}


/**
 * Building upsert
 */
export type BuildingUpsertArgs = {
  /**
   * Select specific fields to fetch from the Building
  **/
  select?: BuildingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BuildingInclude | null
  /**
   * The filter to search for the Building to update in case it exists.
  **/
  where: BuildingWhereUniqueInput
  /**
   * In case the Building found by the `where` argument doesn't exist, create a new Building with this data.
  **/
  create: BuildingCreateInput
  /**
   * In case the Building was found with the provided `where` argument, update it with this data.
  **/
  update: BuildingUpdateInput
}


/**
 * Building delete
 */
export type BuildingDeleteArgs = {
  /**
   * Select specific fields to fetch from the Building
  **/
  select?: BuildingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BuildingInclude | null
  /**
   * Filter which Building to delete.
  **/
  where: BuildingWhereUniqueInput
}


/**
 * Building deleteMany
 */
export type BuildingDeleteManyArgs = {
  where?: BuildingWhereInput
}


/**
 * Building without action
 */
export type BuildingArgs = {
  /**
   * Select specific fields to fetch from the Building
  **/
  select?: BuildingSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: BuildingInclude | null
}



/**
 * Model Unit
 */

export type Unit = {
  id: number
  createdAt: Date
  buildingId: number
  tenantId: number | null
  apt: string
  sale: boolean
}



export type UnitSelect = {
  id?: boolean
  createdAt?: boolean
  buildingId?: boolean
  tenantId?: boolean
  apt?: boolean
  sale?: boolean
  agent?: boolean | FindManyAgentArgs
  building?: boolean | BuildingArgs
  owner?: boolean | FindManyOwnerArgs
  tenant?: boolean | FindManyTenantArgs
}

export type UnitInclude = {
  agent?: boolean | FindManyAgentArgs
  building?: boolean | BuildingArgs
  owner?: boolean | FindManyOwnerArgs
  tenant?: boolean | FindManyTenantArgs
}

export type UnitGetPayload<
  S extends boolean | null | undefined | UnitArgs,
  U = keyof S
> = S extends true
  ? Unit
  : S extends undefined
  ? never
  : S extends UnitArgs | FindManyUnitArgs
  ? 'include' extends U
    ? Unit  & {
      [P in TrueKeys<S['include']>]:
      P extends 'agent'
      ? Array<AgentGetPayload<S['include'][P]>> :
      P extends 'building'
      ? BuildingGetPayload<S['include'][P]> :
      P extends 'owner'
      ? Array<OwnerGetPayload<S['include'][P]>> :
      P extends 'tenant'
      ? Array<TenantGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof Unit ? Unit[P]
: 
      P extends 'agent'
      ? Array<AgentGetPayload<S['select'][P]>> :
      P extends 'building'
      ? BuildingGetPayload<S['select'][P]> :
      P extends 'owner'
      ? Array<OwnerGetPayload<S['select'][P]>> :
      P extends 'tenant'
      ? Array<TenantGetPayload<S['select'][P]>> : never
    }
  : Unit
: Unit


export interface UnitDelegate {
  /**
   * Find zero or one Unit.
   * @param {FindOneUnitArgs} args - Arguments to find a Unit
   * @example
   * // Get one Unit
   * const unit = await prisma.unit.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneUnitArgs>(
    args: Subset<T, FindOneUnitArgs>
  ): CheckSelect<T, Prisma__UnitClient<Unit | null>, Prisma__UnitClient<UnitGetPayload<T> | null>>
  /**
   * Find zero or more Units.
   * @param {FindManyUnitArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Units
   * const units = await prisma.unit.findMany()
   * 
   * // Get first 10 Units
   * const units = await prisma.unit.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyUnitArgs>(
    args?: Subset<T, FindManyUnitArgs>
  ): CheckSelect<T, Promise<Array<Unit>>, Promise<Array<UnitGetPayload<T>>>>
  /**
   * Create a Unit.
   * @param {UnitCreateArgs} args - Arguments to create a Unit.
   * @example
   * // Create one Unit
   * const Unit = await prisma.unit.create({
   *   data: {
   *     // ... data to create a Unit
   *   }
   * })
   * 
  **/
  create<T extends UnitCreateArgs>(
    args: Subset<T, UnitCreateArgs>
  ): CheckSelect<T, Prisma__UnitClient<Unit>, Prisma__UnitClient<UnitGetPayload<T>>>
  /**
   * Delete a Unit.
   * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
   * @example
   * // Delete one Unit
   * const Unit = await prisma.unit.delete({
   *   where: {
   *     // ... filter to delete one Unit
   *   }
   * })
   * 
  **/
  delete<T extends UnitDeleteArgs>(
    args: Subset<T, UnitDeleteArgs>
  ): CheckSelect<T, Prisma__UnitClient<Unit>, Prisma__UnitClient<UnitGetPayload<T>>>
  /**
   * Update one Unit.
   * @param {UnitUpdateArgs} args - Arguments to update one Unit.
   * @example
   * // Update one Unit
   * const unit = await prisma.unit.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends UnitUpdateArgs>(
    args: Subset<T, UnitUpdateArgs>
  ): CheckSelect<T, Prisma__UnitClient<Unit>, Prisma__UnitClient<UnitGetPayload<T>>>
  /**
   * Delete zero or more Units.
   * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
   * @example
   * // Delete a few Units
   * const { count } = await prisma.unit.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends UnitDeleteManyArgs>(
    args: Subset<T, UnitDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Units.
   * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Units
   * const unit = await prisma.unit.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends UnitUpdateManyArgs>(
    args: Subset<T, UnitUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Unit.
   * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
   * @example
   * // Update or create a Unit
   * const unit = await prisma.unit.upsert({
   *   create: {
   *     // ... data to create a Unit
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Unit we want to update
   *   }
   * })
  **/
  upsert<T extends UnitUpsertArgs>(
    args: Subset<T, UnitUpsertArgs>
  ): CheckSelect<T, Prisma__UnitClient<Unit>, Prisma__UnitClient<UnitGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyUnitArgs, 'select' | 'include'>): Promise<number>


}

/**
 * The delegate class that acts as a "Promise-like" for Unit.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__UnitClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  agent<T extends FindManyAgentArgs = {}>(args?: Subset<T, FindManyAgentArgs>): CheckSelect<T, Promise<Array<Agent>>, Promise<Array<AgentGetPayload<T>>>>;

  building<T extends BuildingArgs = {}>(args?: Subset<T, BuildingArgs>): CheckSelect<T, Prisma__BuildingClient<Building | null>, Prisma__BuildingClient<BuildingGetPayload<T> | null>>;

  owner<T extends FindManyOwnerArgs = {}>(args?: Subset<T, FindManyOwnerArgs>): CheckSelect<T, Promise<Array<Owner>>, Promise<Array<OwnerGetPayload<T>>>>;

  tenant<T extends FindManyTenantArgs = {}>(args?: Subset<T, FindManyTenantArgs>): CheckSelect<T, Promise<Array<Tenant>>, Promise<Array<TenantGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * Unit findOne
 */
export type FindOneUnitArgs = {
  /**
   * Select specific fields to fetch from the Unit
  **/
  select?: UnitSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UnitInclude | null
  /**
   * Filter, which Unit to fetch.
  **/
  where: UnitWhereUniqueInput
}


/**
 * Unit findMany
 */
export type FindManyUnitArgs = {
  /**
   * Select specific fields to fetch from the Unit
  **/
  select?: UnitSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UnitInclude | null
  /**
   * Filter, which Units to fetch.
  **/
  where?: UnitWhereInput
  /**
   * Determine the order of the Units to fetch.
  **/
  orderBy?: Enumerable<UnitOrderByInput>
  /**
   * Sets the position for listing Units.
  **/
  cursor?: UnitWhereUniqueInput
  /**
   * The number of Units to fetch. If negative number, it will take Units before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` Units.
  **/
  skip?: number
}


/**
 * Unit create
 */
export type UnitCreateArgs = {
  /**
   * Select specific fields to fetch from the Unit
  **/
  select?: UnitSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UnitInclude | null
  /**
   * The data needed to create a Unit.
  **/
  data: UnitCreateInput
}


/**
 * Unit update
 */
export type UnitUpdateArgs = {
  /**
   * Select specific fields to fetch from the Unit
  **/
  select?: UnitSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UnitInclude | null
  /**
   * The data needed to update a Unit.
  **/
  data: UnitUpdateInput
  /**
   * Choose, which Unit to update.
  **/
  where: UnitWhereUniqueInput
}


/**
 * Unit updateMany
 */
export type UnitUpdateManyArgs = {
  data: UnitUpdateManyMutationInput
  where?: UnitWhereInput
}


/**
 * Unit upsert
 */
export type UnitUpsertArgs = {
  /**
   * Select specific fields to fetch from the Unit
  **/
  select?: UnitSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UnitInclude | null
  /**
   * The filter to search for the Unit to update in case it exists.
  **/
  where: UnitWhereUniqueInput
  /**
   * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
  **/
  create: UnitCreateInput
  /**
   * In case the Unit was found with the provided `where` argument, update it with this data.
  **/
  update: UnitUpdateInput
}


/**
 * Unit delete
 */
export type UnitDeleteArgs = {
  /**
   * Select specific fields to fetch from the Unit
  **/
  select?: UnitSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UnitInclude | null
  /**
   * Filter which Unit to delete.
  **/
  where: UnitWhereUniqueInput
}


/**
 * Unit deleteMany
 */
export type UnitDeleteManyArgs = {
  where?: UnitWhereInput
}


/**
 * Unit without action
 */
export type UnitArgs = {
  /**
   * Select specific fields to fetch from the Unit
  **/
  select?: UnitSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: UnitInclude | null
}



/**
 * Deep Input Types
 */


export type AgentWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  name?: string | StringFilter
  email?: string | StringFilter
  password?: string | StringFilter
  phone?: string | StringFilter
  units?: UnitFilter | null
  AND?: Enumerable<AgentWhereInput>
  OR?: Array<AgentWhereInput>
  NOT?: Enumerable<AgentWhereInput>
}

export type BuildingWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  address?: string | StringFilter
  name?: string | NullableStringFilter | null
  units?: UnitFilter | null
  AND?: Enumerable<BuildingWhereInput>
  OR?: Array<BuildingWhereInput>
  NOT?: Enumerable<BuildingWhereInput>
}

export type TenantWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  name?: string | StringFilter
  phone?: string | NullableStringFilter | null
  email?: string | NullableStringFilter | null
  unitId?: number | NullableIntFilter | null
  AND?: Enumerable<TenantWhereInput>
  OR?: Array<TenantWhereInput>
  NOT?: Enumerable<TenantWhereInput>
  unit?: UnitWhereInput | null
}

export type UnitWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  buildingId?: number | IntFilter
  tenantId?: number | NullableIntFilter | null
  apt?: string | StringFilter
  sale?: boolean | BooleanFilter
  agent?: AgentFilter | null
  owner?: OwnerFilter | null
  tenant?: TenantFilter | null
  AND?: Enumerable<UnitWhereInput>
  OR?: Array<UnitWhereInput>
  NOT?: Enumerable<UnitWhereInput>
  building?: BuildingWhereInput | null
}

export type OwnerWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  name?: string | StringFilter
  phone?: string | NullableStringFilter | null
  email?: string | NullableStringFilter | null
  units?: UnitFilter | null
  AND?: Enumerable<OwnerWhereInput>
  OR?: Array<OwnerWhereInput>
  NOT?: Enumerable<OwnerWhereInput>
}

export type OwnerOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  name?: SortOrder
  phone?: SortOrder
  email?: SortOrder
}

export type OwnerWhereUniqueInput = {
  id?: number
  phone?: string | null
  email?: string | null
}

export type UnitOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  buildingId?: SortOrder
  tenantId?: SortOrder
  apt?: SortOrder
  sale?: SortOrder
}

export type UnitWhereUniqueInput = {
  id?: number
  tenantId?: number | null
}

export type AgentOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  name?: SortOrder
  email?: SortOrder
  password?: SortOrder
  phone?: SortOrder
}

export type AgentWhereUniqueInput = {
  id?: number
  email?: string
  phone?: string
}

export type TenantOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  name?: SortOrder
  phone?: SortOrder
  email?: SortOrder
  unitId?: SortOrder
}

export type TenantWhereUniqueInput = {
  id?: number
  phone?: string | null
  email?: string | null
}

export type BuildingOrderByInput = {
  id?: SortOrder
  createdAt?: SortOrder
  address?: SortOrder
  name?: SortOrder
}

export type BuildingWhereUniqueInput = {
  id?: number
}

export type AgentCreateWithoutUnitsInput = {
  createdAt?: Date | string
  name: string
  email: string
  password: string
  phone: string
}

export type AgentCreateOrConnectWithoutUnitInput = {
  where: AgentWhereUniqueInput
  create: AgentCreateWithoutUnitsInput
}

export type AgentCreateManyWithoutUnitsInput = {
  create?: Enumerable<AgentCreateWithoutUnitsInput>
  connect?: Enumerable<AgentWhereUniqueInput>
  connectOrCreate?: Enumerable<AgentCreateOrConnectWithoutUnitInput>
}

export type BuildingCreateWithoutUnitsInput = {
  createdAt?: Date | string
  address: string
  name?: string | null
}

export type BuildingCreateOrConnectWithoutUnitInput = {
  where: BuildingWhereUniqueInput
  create: BuildingCreateWithoutUnitsInput
}

export type BuildingCreateOneWithoutUnitsInput = {
  create?: BuildingCreateWithoutUnitsInput
  connect?: BuildingWhereUniqueInput
  connectOrCreate?: BuildingCreateOrConnectWithoutUnitInput
}

export type TenantCreateWithoutUnitInput = {
  createdAt?: Date | string
  name: string
  phone?: string | null
  email?: string | null
}

export type TenantCreateOrConnectWithoutUnitInput = {
  where: TenantWhereUniqueInput
  create: TenantCreateWithoutUnitInput
}

export type TenantCreateManyWithoutUnitInput = {
  create?: Enumerable<TenantCreateWithoutUnitInput>
  connect?: Enumerable<TenantWhereUniqueInput>
  connectOrCreate?: Enumerable<TenantCreateOrConnectWithoutUnitInput>
}

export type UnitCreateWithoutOwnerInput = {
  createdAt?: Date | string
  tenantId?: number | null
  apt: string
  sale: boolean
  agent?: AgentCreateManyWithoutUnitsInput
  building: BuildingCreateOneWithoutUnitsInput
  tenant?: TenantCreateManyWithoutUnitInput
}

export type UnitCreateOrConnectWithoutOwnerInput = {
  where: UnitWhereUniqueInput
  create: UnitCreateWithoutOwnerInput
}

export type UnitCreateManyWithoutOwnerInput = {
  create?: Enumerable<UnitCreateWithoutOwnerInput>
  connect?: Enumerable<UnitWhereUniqueInput>
  connectOrCreate?: Enumerable<UnitCreateOrConnectWithoutOwnerInput>
}

export type OwnerCreateInput = {
  createdAt?: Date | string
  name: string
  phone?: string | null
  email?: string | null
  units?: UnitCreateManyWithoutOwnerInput
}

export type AgentUpdateWithoutUnitsDataInput = {
  createdAt?: Date | string
  name?: string
  email?: string
  password?: string
  phone?: string
}

export type AgentUpdateWithWhereUniqueWithoutUnitsInput = {
  where: AgentWhereUniqueInput
  data: AgentUpdateWithoutUnitsDataInput
}

export type AgentScalarWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  name?: string | StringFilter
  email?: string | StringFilter
  password?: string | StringFilter
  phone?: string | StringFilter
  units?: UnitFilter | null
  AND?: Enumerable<AgentScalarWhereInput>
  OR?: Array<AgentScalarWhereInput>
  NOT?: Enumerable<AgentScalarWhereInput>
}

export type AgentUpdateManyDataInput = {
  createdAt?: Date | string
  name?: string
  email?: string
  password?: string
  phone?: string
}

export type AgentUpdateManyWithWhereNestedInput = {
  where: AgentScalarWhereInput
  data: AgentUpdateManyDataInput
}

export type AgentUpsertWithWhereUniqueWithoutUnitsInput = {
  where: AgentWhereUniqueInput
  update: AgentUpdateWithoutUnitsDataInput
  create: AgentCreateWithoutUnitsInput
}

export type AgentUpdateManyWithoutUnitsInput = {
  create?: Enumerable<AgentCreateWithoutUnitsInput>
  connect?: Enumerable<AgentWhereUniqueInput>
  set?: Enumerable<AgentWhereUniqueInput>
  disconnect?: Enumerable<AgentWhereUniqueInput>
  delete?: Enumerable<AgentWhereUniqueInput>
  update?: Enumerable<AgentUpdateWithWhereUniqueWithoutUnitsInput>
  updateMany?: Enumerable<AgentUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<AgentScalarWhereInput>
  upsert?: Enumerable<AgentUpsertWithWhereUniqueWithoutUnitsInput>
  connectOrCreate?: Enumerable<AgentCreateOrConnectWithoutUnitInput>
}

export type BuildingUpdateWithoutUnitsDataInput = {
  createdAt?: Date | string
  address?: string
  name?: string | null
}

export type BuildingUpsertWithoutUnitsInput = {
  update: BuildingUpdateWithoutUnitsDataInput
  create: BuildingCreateWithoutUnitsInput
}

export type BuildingUpdateOneRequiredWithoutUnitsInput = {
  create?: BuildingCreateWithoutUnitsInput
  connect?: BuildingWhereUniqueInput
  update?: BuildingUpdateWithoutUnitsDataInput
  upsert?: BuildingUpsertWithoutUnitsInput
  connectOrCreate?: BuildingCreateOrConnectWithoutUnitInput
}

export type TenantUpdateWithoutUnitDataInput = {
  createdAt?: Date | string
  name?: string
  phone?: string | null
  email?: string | null
}

export type TenantUpdateWithWhereUniqueWithoutUnitInput = {
  where: TenantWhereUniqueInput
  data: TenantUpdateWithoutUnitDataInput
}

export type TenantScalarWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  name?: string | StringFilter
  phone?: string | NullableStringFilter | null
  email?: string | NullableStringFilter | null
  unitId?: number | NullableIntFilter | null
  AND?: Enumerable<TenantScalarWhereInput>
  OR?: Array<TenantScalarWhereInput>
  NOT?: Enumerable<TenantScalarWhereInput>
}

export type TenantUpdateManyDataInput = {
  createdAt?: Date | string
  name?: string
  phone?: string | null
  email?: string | null
}

export type TenantUpdateManyWithWhereNestedInput = {
  where: TenantScalarWhereInput
  data: TenantUpdateManyDataInput
}

export type TenantUpsertWithWhereUniqueWithoutUnitInput = {
  where: TenantWhereUniqueInput
  update: TenantUpdateWithoutUnitDataInput
  create: TenantCreateWithoutUnitInput
}

export type TenantUpdateManyWithoutUnitInput = {
  create?: Enumerable<TenantCreateWithoutUnitInput>
  connect?: Enumerable<TenantWhereUniqueInput>
  set?: Enumerable<TenantWhereUniqueInput>
  disconnect?: Enumerable<TenantWhereUniqueInput>
  delete?: Enumerable<TenantWhereUniqueInput>
  update?: Enumerable<TenantUpdateWithWhereUniqueWithoutUnitInput>
  updateMany?: Enumerable<TenantUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<TenantScalarWhereInput>
  upsert?: Enumerable<TenantUpsertWithWhereUniqueWithoutUnitInput>
  connectOrCreate?: Enumerable<TenantCreateOrConnectWithoutUnitInput>
}

export type UnitUpdateWithoutOwnerDataInput = {
  createdAt?: Date | string
  tenantId?: number | null
  apt?: string
  sale?: boolean
  agent?: AgentUpdateManyWithoutUnitsInput
  building?: BuildingUpdateOneRequiredWithoutUnitsInput
  tenant?: TenantUpdateManyWithoutUnitInput
}

export type UnitUpdateWithWhereUniqueWithoutOwnerInput = {
  where: UnitWhereUniqueInput
  data: UnitUpdateWithoutOwnerDataInput
}

export type UnitScalarWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  buildingId?: number | IntFilter
  tenantId?: number | NullableIntFilter | null
  apt?: string | StringFilter
  sale?: boolean | BooleanFilter
  agent?: AgentFilter | null
  owner?: OwnerFilter | null
  tenant?: TenantFilter | null
  AND?: Enumerable<UnitScalarWhereInput>
  OR?: Array<UnitScalarWhereInput>
  NOT?: Enumerable<UnitScalarWhereInput>
}

export type UnitUpdateManyDataInput = {
  createdAt?: Date | string
  tenantId?: number | null
  apt?: string
  sale?: boolean
}

export type UnitUpdateManyWithWhereNestedInput = {
  where: UnitScalarWhereInput
  data: UnitUpdateManyDataInput
}

export type UnitUpsertWithWhereUniqueWithoutOwnerInput = {
  where: UnitWhereUniqueInput
  update: UnitUpdateWithoutOwnerDataInput
  create: UnitCreateWithoutOwnerInput
}

export type UnitUpdateManyWithoutOwnerInput = {
  create?: Enumerable<UnitCreateWithoutOwnerInput>
  connect?: Enumerable<UnitWhereUniqueInput>
  set?: Enumerable<UnitWhereUniqueInput>
  disconnect?: Enumerable<UnitWhereUniqueInput>
  delete?: Enumerable<UnitWhereUniqueInput>
  update?: Enumerable<UnitUpdateWithWhereUniqueWithoutOwnerInput>
  updateMany?: Enumerable<UnitUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<UnitScalarWhereInput>
  upsert?: Enumerable<UnitUpsertWithWhereUniqueWithoutOwnerInput>
  connectOrCreate?: Enumerable<UnitCreateOrConnectWithoutOwnerInput>
}

export type OwnerUpdateInput = {
  createdAt?: Date | string
  name?: string
  phone?: string | null
  email?: string | null
  units?: UnitUpdateManyWithoutOwnerInput
}

export type OwnerUpdateManyMutationInput = {
  createdAt?: Date | string
  name?: string
  phone?: string | null
  email?: string | null
}

export type OwnerCreateWithoutUnitsInput = {
  createdAt?: Date | string
  name: string
  phone?: string | null
  email?: string | null
}

export type OwnerCreateOrConnectWithoutUnitInput = {
  where: OwnerWhereUniqueInput
  create: OwnerCreateWithoutUnitsInput
}

export type OwnerCreateManyWithoutUnitsInput = {
  create?: Enumerable<OwnerCreateWithoutUnitsInput>
  connect?: Enumerable<OwnerWhereUniqueInput>
  connectOrCreate?: Enumerable<OwnerCreateOrConnectWithoutUnitInput>
}

export type UnitCreateWithoutTenantInput = {
  createdAt?: Date | string
  tenantId?: number | null
  apt: string
  sale: boolean
  agent?: AgentCreateManyWithoutUnitsInput
  building: BuildingCreateOneWithoutUnitsInput
  owner?: OwnerCreateManyWithoutUnitsInput
}

export type UnitCreateOrConnectWithoutTenantInput = {
  where: UnitWhereUniqueInput
  create: UnitCreateWithoutTenantInput
}

export type UnitCreateOneWithoutTenantInput = {
  create?: UnitCreateWithoutTenantInput
  connect?: UnitWhereUniqueInput
  connectOrCreate?: UnitCreateOrConnectWithoutTenantInput
}

export type TenantCreateInput = {
  createdAt?: Date | string
  name: string
  phone?: string | null
  email?: string | null
  unit?: UnitCreateOneWithoutTenantInput
}

export type OwnerUpdateWithoutUnitsDataInput = {
  createdAt?: Date | string
  name?: string
  phone?: string | null
  email?: string | null
}

export type OwnerUpdateWithWhereUniqueWithoutUnitsInput = {
  where: OwnerWhereUniqueInput
  data: OwnerUpdateWithoutUnitsDataInput
}

export type OwnerScalarWhereInput = {
  id?: number | IntFilter
  createdAt?: Date | string | DateTimeFilter
  name?: string | StringFilter
  phone?: string | NullableStringFilter | null
  email?: string | NullableStringFilter | null
  units?: UnitFilter | null
  AND?: Enumerable<OwnerScalarWhereInput>
  OR?: Array<OwnerScalarWhereInput>
  NOT?: Enumerable<OwnerScalarWhereInput>
}

export type OwnerUpdateManyDataInput = {
  createdAt?: Date | string
  name?: string
  phone?: string | null
  email?: string | null
}

export type OwnerUpdateManyWithWhereNestedInput = {
  where: OwnerScalarWhereInput
  data: OwnerUpdateManyDataInput
}

export type OwnerUpsertWithWhereUniqueWithoutUnitsInput = {
  where: OwnerWhereUniqueInput
  update: OwnerUpdateWithoutUnitsDataInput
  create: OwnerCreateWithoutUnitsInput
}

export type OwnerUpdateManyWithoutUnitsInput = {
  create?: Enumerable<OwnerCreateWithoutUnitsInput>
  connect?: Enumerable<OwnerWhereUniqueInput>
  set?: Enumerable<OwnerWhereUniqueInput>
  disconnect?: Enumerable<OwnerWhereUniqueInput>
  delete?: Enumerable<OwnerWhereUniqueInput>
  update?: Enumerable<OwnerUpdateWithWhereUniqueWithoutUnitsInput>
  updateMany?: Enumerable<OwnerUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<OwnerScalarWhereInput>
  upsert?: Enumerable<OwnerUpsertWithWhereUniqueWithoutUnitsInput>
  connectOrCreate?: Enumerable<OwnerCreateOrConnectWithoutUnitInput>
}

export type UnitUpdateWithoutTenantDataInput = {
  createdAt?: Date | string
  tenantId?: number | null
  apt?: string
  sale?: boolean
  agent?: AgentUpdateManyWithoutUnitsInput
  building?: BuildingUpdateOneRequiredWithoutUnitsInput
  owner?: OwnerUpdateManyWithoutUnitsInput
}

export type UnitUpsertWithoutTenantInput = {
  update: UnitUpdateWithoutTenantDataInput
  create: UnitCreateWithoutTenantInput
}

export type UnitUpdateOneWithoutTenantInput = {
  create?: UnitCreateWithoutTenantInput
  connect?: UnitWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: UnitUpdateWithoutTenantDataInput
  upsert?: UnitUpsertWithoutTenantInput
  connectOrCreate?: UnitCreateOrConnectWithoutTenantInput
}

export type TenantUpdateInput = {
  createdAt?: Date | string
  name?: string
  phone?: string | null
  email?: string | null
  unit?: UnitUpdateOneWithoutTenantInput
}

export type TenantUpdateManyMutationInput = {
  createdAt?: Date | string
  name?: string
  phone?: string | null
  email?: string | null
}

export type UnitCreateWithoutAgentInput = {
  createdAt?: Date | string
  tenantId?: number | null
  apt: string
  sale: boolean
  building: BuildingCreateOneWithoutUnitsInput
  owner?: OwnerCreateManyWithoutUnitsInput
  tenant?: TenantCreateManyWithoutUnitInput
}

export type UnitCreateOrConnectWithoutAgentInput = {
  where: UnitWhereUniqueInput
  create: UnitCreateWithoutAgentInput
}

export type UnitCreateManyWithoutAgentInput = {
  create?: Enumerable<UnitCreateWithoutAgentInput>
  connect?: Enumerable<UnitWhereUniqueInput>
  connectOrCreate?: Enumerable<UnitCreateOrConnectWithoutAgentInput>
}

export type AgentCreateInput = {
  createdAt?: Date | string
  name: string
  email: string
  password: string
  phone: string
  units?: UnitCreateManyWithoutAgentInput
}

export type UnitUpdateWithoutAgentDataInput = {
  createdAt?: Date | string
  tenantId?: number | null
  apt?: string
  sale?: boolean
  building?: BuildingUpdateOneRequiredWithoutUnitsInput
  owner?: OwnerUpdateManyWithoutUnitsInput
  tenant?: TenantUpdateManyWithoutUnitInput
}

export type UnitUpdateWithWhereUniqueWithoutAgentInput = {
  where: UnitWhereUniqueInput
  data: UnitUpdateWithoutAgentDataInput
}

export type UnitUpsertWithWhereUniqueWithoutAgentInput = {
  where: UnitWhereUniqueInput
  update: UnitUpdateWithoutAgentDataInput
  create: UnitCreateWithoutAgentInput
}

export type UnitUpdateManyWithoutAgentInput = {
  create?: Enumerable<UnitCreateWithoutAgentInput>
  connect?: Enumerable<UnitWhereUniqueInput>
  set?: Enumerable<UnitWhereUniqueInput>
  disconnect?: Enumerable<UnitWhereUniqueInput>
  delete?: Enumerable<UnitWhereUniqueInput>
  update?: Enumerable<UnitUpdateWithWhereUniqueWithoutAgentInput>
  updateMany?: Enumerable<UnitUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<UnitScalarWhereInput>
  upsert?: Enumerable<UnitUpsertWithWhereUniqueWithoutAgentInput>
  connectOrCreate?: Enumerable<UnitCreateOrConnectWithoutAgentInput>
}

export type AgentUpdateInput = {
  createdAt?: Date | string
  name?: string
  email?: string
  password?: string
  phone?: string
  units?: UnitUpdateManyWithoutAgentInput
}

export type AgentUpdateManyMutationInput = {
  createdAt?: Date | string
  name?: string
  email?: string
  password?: string
  phone?: string
}

export type UnitCreateWithoutBuildingInput = {
  createdAt?: Date | string
  tenantId?: number | null
  apt: string
  sale: boolean
  agent?: AgentCreateManyWithoutUnitsInput
  owner?: OwnerCreateManyWithoutUnitsInput
  tenant?: TenantCreateManyWithoutUnitInput
}

export type UnitCreateOrConnectWithoutBuildingInput = {
  where: UnitWhereUniqueInput
  create: UnitCreateWithoutBuildingInput
}

export type UnitCreateManyWithoutBuildingInput = {
  create?: Enumerable<UnitCreateWithoutBuildingInput>
  connect?: Enumerable<UnitWhereUniqueInput>
  connectOrCreate?: Enumerable<UnitCreateOrConnectWithoutBuildingInput>
}

export type BuildingCreateInput = {
  createdAt?: Date | string
  address: string
  name?: string | null
  units?: UnitCreateManyWithoutBuildingInput
}

export type UnitUpdateWithoutBuildingDataInput = {
  createdAt?: Date | string
  tenantId?: number | null
  apt?: string
  sale?: boolean
  agent?: AgentUpdateManyWithoutUnitsInput
  owner?: OwnerUpdateManyWithoutUnitsInput
  tenant?: TenantUpdateManyWithoutUnitInput
}

export type UnitUpdateWithWhereUniqueWithoutBuildingInput = {
  where: UnitWhereUniqueInput
  data: UnitUpdateWithoutBuildingDataInput
}

export type UnitUpsertWithWhereUniqueWithoutBuildingInput = {
  where: UnitWhereUniqueInput
  update: UnitUpdateWithoutBuildingDataInput
  create: UnitCreateWithoutBuildingInput
}

export type UnitUpdateManyWithoutBuildingInput = {
  create?: Enumerable<UnitCreateWithoutBuildingInput>
  connect?: Enumerable<UnitWhereUniqueInput>
  set?: Enumerable<UnitWhereUniqueInput>
  disconnect?: Enumerable<UnitWhereUniqueInput>
  delete?: Enumerable<UnitWhereUniqueInput>
  update?: Enumerable<UnitUpdateWithWhereUniqueWithoutBuildingInput>
  updateMany?: Enumerable<UnitUpdateManyWithWhereNestedInput> | null
  deleteMany?: Enumerable<UnitScalarWhereInput>
  upsert?: Enumerable<UnitUpsertWithWhereUniqueWithoutBuildingInput>
  connectOrCreate?: Enumerable<UnitCreateOrConnectWithoutBuildingInput>
}

export type BuildingUpdateInput = {
  createdAt?: Date | string
  address?: string
  name?: string | null
  units?: UnitUpdateManyWithoutBuildingInput
}

export type BuildingUpdateManyMutationInput = {
  createdAt?: Date | string
  address?: string
  name?: string | null
}

export type UnitCreateInput = {
  createdAt?: Date | string
  tenantId?: number | null
  apt: string
  sale: boolean
  agent?: AgentCreateManyWithoutUnitsInput
  building: BuildingCreateOneWithoutUnitsInput
  owner?: OwnerCreateManyWithoutUnitsInput
  tenant?: TenantCreateManyWithoutUnitInput
}

export type UnitUpdateInput = {
  createdAt?: Date | string
  tenantId?: number | null
  apt?: string
  sale?: boolean
  agent?: AgentUpdateManyWithoutUnitsInput
  building?: BuildingUpdateOneRequiredWithoutUnitsInput
  owner?: OwnerUpdateManyWithoutUnitsInput
  tenant?: TenantUpdateManyWithoutUnitInput
}

export type UnitUpdateManyMutationInput = {
  createdAt?: Date | string
  tenantId?: number | null
  apt?: string
  sale?: boolean
}

export type IntFilter = {
  equals?: number
  not?: number | IntFilter
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
}

export type DateTimeFilter = {
  equals?: Date | string
  not?: Date | string | DateTimeFilter
  in?: Enumerable<Date | string>
  notIn?: Enumerable<Date | string>
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
}

export type StringFilter = {
  equals?: string
  not?: string | StringFilter
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
}

export type UnitFilter = {
  every?: UnitWhereInput
  some?: UnitWhereInput
  none?: UnitWhereInput
}

export type NullableStringFilter = {
  equals?: string | null
  not?: string | null | NullableStringFilter
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string | null
  lte?: string | null
  gt?: string | null
  gte?: string | null
  contains?: string | null
  startsWith?: string | null
  endsWith?: string | null
}

export type NullableIntFilter = {
  equals?: number | null
  not?: number | null | NullableIntFilter
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number | null
  lte?: number | null
  gt?: number | null
  gte?: number | null
}

export type BooleanFilter = {
  equals?: boolean
  not?: boolean | BooleanFilter
}

export type AgentFilter = {
  every?: AgentWhereInput
  some?: AgentWhereInput
  none?: AgentWhereInput
}

export type OwnerFilter = {
  every?: OwnerWhereInput
  some?: OwnerWhereInput
  none?: OwnerWhereInput
}

export type TenantFilter = {
  every?: TenantWhereInput
  some?: TenantWhereInput
  none?: TenantWhereInput
}

/**
 * Batch Payload for updateMany & deleteMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
